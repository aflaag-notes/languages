\documentclass[a4paper, 12pt]{report}

%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage{../Nyx/nyx-packages}
\usepackage{../Nyx/nyx-styles}
\usepackage{../Nyx/nyx-frames}
\usepackage{../Nyx/nyx-title}
\usepackage{../Nyx/nyx-macros}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{../Nyx/logo.png}

\institute{\curlyquotes{\hspace{0.25mm}Sapienza} Università di Roma}
\faculty{Ingegneria dell'Informazione,\\Informatica e Statistica}
\department{Dipartimento di Informatica}

\title{Linguaggi di Programmazione}
\subtitle{Appunti integrati con il libro "TODO", TODO 1, Autore 2, ...}

% \author{\textit{Author}\\TODO: DECOMMENTARE QUESTA SEZIONE}
% \author{\textit{Author}\\Simone Bianco}
\author{\textit{Author}\\Alessio Bandiera}
% \supervisor{Linus \textsc{Torvalds}}
% \context{Well, I was bored\ldots}

\date{\today}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
    \maketitle

    % The following style changes are valid only inside this scope 
    {
        \hypersetup{allcolors=black}
        \fancypagestyle{plain}{%
        \fancyhead{}        % clear all header fields
        \fancyfoot{}        % clear all header fields
        \fancyfoot[C]{\thepage}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}}

        \romantableofcontents
    }

    \chapter*{Informazioni e Contatti}      % \chapter* makes this a "fake" chapter
    \markboth{Informazioni e Contatti}{}    % Manually sets \leftmark (current chapter name)
    \addcontentsline{toc}{chapter}{Informazioni e Contatti}     % Manually adds chapter to ToC
    
    \subsubsection{Prerequisiti consigliati:}
    \begin{itemize}
        \item Algebra
        \item TODO
    \end{itemize}

    \quad

    \subsubsection{Segnalazione errori ed eventuali migliorie:}
    
    Per segnalare eventuali errori e/o migliorie possibili, si prega di utilizzare il \textbf{sistema di Issues fornito da GitHub} all'interno della pagina della repository stessa contenente questi ed altri appunti (link fornito al di sotto), utilizzando uno dei template già forniti compilando direttamente i campi richiesti.

    Gli appunti sono in continuo aggiornamento, pertanto, previa segnalazione, si prega di controllare se l'errore sia ancora presente nella versione più recente.

    \quad

    \subsubsection{Licenza di distribuzione:}
    
    These documents are distributed under the \textbf{\href{https://www.gnu.org/licenses/fdl-1.3.txt}{GNU Free Documentation License}}, a form of copyleft intended to be used on manuals, textbooks or other types of document in order to assure everyone the effective freedom to copy and redistribute it, with or without modifications, either commercially or non-commercially.
    
    \quad

    \subsubsection{Contatti dell'autore e ulteriori link:}
    \begin{itemize}
        % \item TODO: DECOMMENTARE QUESTA SEZIONE

        % Simone
        % 
        % \item Altri appunti: \textbf{\href{https://github.com/Exyss/university-notes}{https://github.com/Exyss/university-notes}}
        % \item Github: \textbf{\href{https://github.com/Exyss}{https://github.com/Exyss}}
        % \item Email: \textbf{\href{mailto:bianco.simone@outlook.it}{bianco.simone@outlook.it}}
        % \item LinkedIn: \textbf{\href{https://www.linkedin.com/in/simone-bianco}{Simone Bianco}}

        % Alessio
        % 
        \item Github: \textbf{\href{https://github.com/ph04}{https://github.com/ph04}}
        \item Email: \textbf{\href{mailto:alessio.bandiera02@gmail.com}{alessio.bandiera02@gmail.com}}
        \item LinkedIn: \textbf{\href{https://www.linkedin.com/in/alessio-bandiera-a53767223/}{Alessio Bandiera}}
    \end{itemize}

    %%%%%%%%%%%%%%%%%%%%%

    \chapter{TODO}
    
    \section{TODO}

    \subsection{TODO}

    \begin{frameddefn}[label={peano}]{Assiomi di Peano}
        Gli \tbf{assiomi di Peano} sono 5 assiomi che definiscono l'insieme $\N$, e sono i seguenti:

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $0 \in \N$
            \item $\exists \func{\mathrm{succ}}{\N}{\N}$, o equivalentemente, $\forall x \in \N \quad \mathrm{succ}(x) \in \N$
            \item $\forall x, y \in \N \quad x \neq y \implies \mathrm{succ}(x) \neq \mathrm{succ}(y)$
            \item $\nexists x \in \N \mid \mathrm{succ}(x) = 0$
            \item $\forall S \subseteq \N \quad (0 \in S \land (\forall x \in S \quad \mathrm{succ}(x) \in S)) \implies S = \N$
        \end{enumerate}
    \end{frameddefn}

    \begin{example}[$\N$ di von Neumann]
        Una rappresentazione dell'insieme dei numeri naturali $\N$ alternativa alla canonica $$\N := \{0, 1, 2, \ldots \}$$ è stata fornita da John von Neumann. Indicando tale rappresentazione con $\aleph$, si ha che, per Neumann $$\begin{array}{c} 0_\aleph := \varnothing  = \{\} \\ 1_\aleph := \{ 0_\aleph \} = \{ \{ \}\} \\ 2_\aleph := \{0_\aleph, 1_\aleph\} = \{\{\}, \{\{ \}\}\} \\ \vdots \end{array}$$ e la funzione $\mathrm{succ}_\aleph$ è definita come segue $$\funcmap{\mathrm{succ}_\aleph}{\aleph}{\aleph}{x_\aleph}{x_\aleph \cup \{x_\aleph\} = \{\mu_\aleph \in \aleph \mid |\mu_\aleph| \le |x_\aleph|\}}$$ ed in particolare $\forall x_\aleph \in \aleph \quad |x_\aleph| + 1 = |\mathrm{succ}_\aleph(x_\aleph)|$.

        È possibile verificare che tale rappresentazione di $\N$ soddisfa gli assiomi di Peano, in quanto

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $0_\aleph := \varnothing \in \aleph$
            \item $\exists \func{\mathrm{succ}_\aleph}{\aleph}{\aleph}$, definita precedentemente
            \item $\forall x_\aleph, y_\aleph \in \aleph \quad x_\aleph \neq y_\aleph \implies |x_\aleph| \neq |y_\aleph| \implies  |\mathrm{succ}_\aleph(x_\aleph)| \neq |\mathrm{succ}_\aleph(y_\aleph)| \implies \mathrm{succ}_\aleph(x_\aleph) \neq \mathrm{succ}_\aleph(y_\aleph)$ 
            \item per assurdo, sia $x_\aleph \in \aleph$ tale che $\mathrm{succ}_\aleph(x_\aleph) = 0_\aleph := \varnothing$; per definizione $\mathrm{succ}_\aleph(x_\aleph) := \{\mu_\aleph \in \aleph \mid |\mu_\aleph| \le |x_\aleph|\}$, ma non esiste $\mu_\aleph \in \aleph$ con cardinalità minore o uguale 0, e dunque $\nexists x_\aleph \in \aleph \mid \mathrm{succ}_\aleph(x_\aleph) = 0_\aleph$
            \item per assurdo, sia $S \subseteq \aleph$ tale che $0_\aleph \in S$ e $\forall x_S \in S \quad \mathrm{succ}_\aleph(x_S) \in S$ ma $S \neq \aleph \iff \aleph - S \neq \varnothing$; $\aleph$ è chiuso su $\mathrm{succ}_\aleph$ per il secondo assioma di Peano, ed in particolare $\aleph - S$ è chiuso attraverso la definizione di successore, il quale presenterà dunque una successione di elementi definita dalla funzione $\mathrm{succ}_\aleph$ stessa; inoltre, si noti che tale successione non può costituire un ciclo per come $\mathrm{succ}_\aleph$ è definta, dunque la funzione genera necessariamente una successione in cui è presente un primo elemento $\zeta_\aleph$ che non ha predecessore in $\aleph - S$, ma che possiede un predecessore poiché $0_\aleph \in S$ in ipotesi, e dunque sicuramente $\zeta_\aleph \neq 0_\aleph$; allora, il predecesssore di $\zeta_\aleph$ deve necessariamente essere in $S$, e sia questo $\zeta'_\aleph \in S$; infine poiché $S$ è definito tale da essere chiuso su $\mathrm{succ}_\aleph$, dal fatto che $\soe{l}{\zeta'_\aleph \in S \\ \mathrm{succ}_\aleph(\zeta'_\aleph) = \zeta_\aleph}$ segue che $\zeta_\aleph \in S$, e tale ragionamento è possibile applicarlo per ogni elemento che segue da $\zeta_\aleph$ in $\aleph - S$ nella successione definita da $\mathrm{succ}_\aleph$; in conlcusione, $S = \aleph$ necessariamente.
        \end{enumerate}
    \end{example}

    \begin{framedprinc}[label={induction}]{Principio di Induzione}
        Sia $P$ una proprietà che vale per $n = 0$, e dunque $P(0)$ è vera; inoltre,  per ogni $n \in \N$ si ha che $P(n) \implies P(n + 1)$; allora, $P(n)$ è vera per ogni $n \in \N$.

        In simboli $$\forall P \quad (P(0) \land (\forall n \in \N \quad P(n) \implies P(n + 1))) \implies \forall n \in \N \quad P(n)$$
    \end{framedprinc}

    \begin{framedobs}{Quinto assioma di Peano}
        Si noti che il quinto degli assiomi di Peano (\cref{peano}) equivale al principio di induzione (\cref{induction}). Infatti, il quinto assioma afferma che qualsiasi sottoinsieme $S$ di $\N$ avente lo 0, e caratterizzato dalla chiusura sulla funzione di successore $\mathrm{succ}$, coincide con $\N$ stesso.
    \end{framedobs}

    \begin{frameddefn}{Algebra}
        Una \tbf{struttura algebrica}, o più semplicemente \tbf{algebra}, consiste di un insieme \tit{non vuoto}, talvolta chiamato \tbf{insieme sostegno} (\tit{carrier set} o \tit{domain}), fornito di una o più operazioni su tale insieme, quest'ultime caratterizzate da un numero finito di assiomi da soddisfare.

        Se $A$ è il carrier set, e $\gamma_1, \ldots \gamma_n$ sono delle operazioni definite su $A$, allora con $$(A, \gamma_1, \ldots, \gamma_n)$$ si indica l'algebra costituita da tali componenti.
    \end{frameddefn}

    \begin{example}[Strutture algebriche con singola operazione]
        Esempi di strutture algebriche con un'operazione binaria sono i seguenti:

        \begin{itemize}
            \item semigruppi
            \item monoidi
            \item gruppi
            \item gruppi abeliani
        \end{itemize}
    \end{example}

    \begin{example}[Strutture algebriche con due operazioni]
        Esempi di strutture algebriche con due operazioni binarie sono i seguenti:

        \begin{itemize}
            \item semianelli
            \item anelli
            \item campi
        \end{itemize}
    \end{example}

    \begin{frameddefn}{Insieme unità}
        Con \tbf{insieme unità} verrà inteso un qualsiasi insieme tale che $\abs{\1} = 1$, e verrà indicato attraverso il simbolo $\1$.
    \end{frameddefn}

    \begin{frameddefn}[label={inductive algebra}]{Algebra induttiva}
        Sia $A$ un insieme, e siano $\gamma_1, \ldots, \gamma_n$ funzioni definite su $A$ di arbitraria arietà; allora, $(A, \gamma_1, \ldots, \gamma_n)$ è definita \tbf{algebra induttiva} se si verificano le seguenti:

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $\gamma_1, \ldots, \gamma_n$ sono iniettive
            \item $\forall i, j \in [1, n] \mid i \neq j \quad \im(\gamma_i) \cap \im(\gamma_j) = \varnothing$, ovvero, le immagini dei costruttori sono a due a due disgiunte
            \item $\forall S \subseteq A \quad (\forall i \in [1, n], a_1, \ldots a_k \in S, k \in \N  \quad \gamma_i(a_1, \ldots, a_k) \in S) \implies S = A$, o equivalentemente, in $A$ non devono essere contenute algebre induttive.
        \end{enumerate}
    \end{frameddefn}

    % \begin{framedobs}{Terzo assioma delle algebre induttive}
    %     Si noti che nel terzo assioma della \cref{inductive algebra} anche $S = \varnothing$ è un valido sottoinsieme di $A$, ma poiché non esistono $a_1, \ldots, a_k \in S \in \varnothing$, in esso ogni qualificazione è vera a vuoto.
    % \end{framedobs}

    \begin{example}[Numeri naturali]
        $(\N, +)$ non è un algebra induttiva, poiché esistono $x_1, x_2, x_3, x_4 \in \N$ con $x_1 \neq x_3$ e $x_2 \neq x_4$ tali che $x_1 + x_2 = x_3 + x_4$; ad esempio, 2 + 3 = 5 = 1 + 4, e 2 $\neq$ 1, 3 $\neq$ 4.
    \end{example}

    % \begin{example}[Algebra di Boole]
    %     Dato l'insieme $B = \{ \mathrm{true}, \mathrm{false}\}$, e la funzione $\lnot$ definita come segue $$\funcmap{\lnot}{B}{B}{x}{\left \{ \begin{array}{ll} \mathrm{false} & x = \mathrm{true} \\ \mathrm{true} & x = \mathrm{false} \end{array} \right.}$$ è possibile dimostrare che l'algebra $(B, \lnot)$ non è induttiva; infatti, nonostante $\lnot$ sia iniettiva, e la seconda proprietà della \cref{inductive algebra} sia vera a vuoto, si ha che $\forall x \in \varnothing \subseteq B \quad \nexists \lnot(x)$
    % \end{example}

    \begin{example}[Algebre induttive]
        Sia $\mathrm{zero}$ la funzione definita come segue $$\funcmap{\mathrm{zero}}{\1}{\N}{x}{0}$$ e si prenda in esame l'algebra $(\N, \mathrm{succ}, \mathrm{zero})$; allora si ha che

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $\mathrm{succ}$ e $\mathrm{zero}$ sono iniettive, poiché
                \begin{itemize}
                    \item $\mathrm{succ}$ è iniettiva per il terzo assioma di Peano (\cref{peano})
                    \item $\forall x, y \in \1 \quad \mathrm{zero}(x) = \mathrm{zero}(y) \implies x = y$ poiché $x, y \in \1 \implies x = y$ in quanto $\abs{\1} = 1$
                \end{itemize}
            \item $\im(\mathrm{succ}) \cap \im(\mathrm{zero}) = \left(\N - \{0\}\right) \cap \{0\} = \varnothing$
            \item TODO
        \end{enumerate}
    \end{example}

    \begin{frameddefn}{Omomorfismo}
        Un \tbf{omomorfismo} è una funzione, tra due algebre dello stesso tipo, tale da preservarne le strutture.

        Formalmente, siano $(A, \mu_1, \ldots, \mu_n)$ e $(B, \delta_1, \ldots, \delta_n)$ due algebre tali che ogni funzione $\mu_i$ abbia la stessa arietà e lo stesso numero di parametri esterni (denotati con $k$) di $\delta_i$, pari rispettivamente ad $\eta_i$ ed a $\nu_i$, per qualche $i \in [1, n]$; allora, una funzione $\func{f}{A}{B}$ è detta essere un \tbf{omomorfismo} tra le due algebre, se e solo se $$\begin{array}{c} \forall a_1, \ldots, a_{\eta_1} \quad f(\mu_1(a_1, \ldots, a_{\eta_n}), k_1, \ldots, k_{\nu_1}) = \delta_1(f(a_1), \ldots, f(a_{\eta_1}), k_1, \ldots, k_{\nu_1}) \\ \vdots \\ \forall a_1, \ldots, a_{\eta_n} \quad f(\mu_n(a_1, \ldots, a_{\eta_n}), k_1, \ldots, k_{\nu_n}) = \delta_n(f(a_1), \ldots, f(a_{\eta_n}), k_1, \ldots, k_{\nu_n}) \end{array}$$
    \end{frameddefn}

    \begin{example}[Omomorfismi]
        \label{homo}
        Si considerino i gruppi $(\R, +)$ e $(\R_{> 0}, \cdot)$, e sia $f$ definita come segue: $$\funcmap{f}{\R}{\R_{> 0}}{x}{e^x}$$ allora, si ha che $$\forall x, y \in \R \quad f(x) \cdot f(y) = e^x \cdot e^y = e^{x + y} = f(x + y)$$ dunque $f$ è un omomorfismo di gruppi.
    \end{example}

    \begin{frameddefn}{Isomorfismo}
        Un \tbf{isomorfismo} è un omomorfismo biettivo.
    \end{frameddefn}

    \begin{example}[Isomorfismi]
        Si consideri l'omomorfismo dell'\cref{homo}; si noti che $$\forall x, y \in \R \mid x \neq \R \quad e^x \neq e^y \implies f(x) \neq f(y)$$ e dunque $f$ è iniettiva; inoltre $$\forall y \in \R_{> 0} \quad \exists x \in \R \mid f(x) = e^x = y \iff y = \ln(x)$$ e dunque $f$ è suriettiva. Allora, $f$ è biettiva, e poiché è un omomorfismo, risulta essere un isomorfismo.
    \end{example}

    \section{Strutture dati induttive}

    \subsection{Liste}

    \begin{frameddefn}{Liste}
        Una \tbf{lista} è una collezione ordinata di elementi, e l'insieme delle liste di lunghezza finita viene denotato con $\ttt{List<T>}$, dove $\ttt T$ è il tipo degli elementi che le liste contengono, ed il simobolo $\ttt T$ verrà identificato con l'insieme di tutti gli oggetti aventi tipo $\ttt T$.

        Dati $a_1, \ldots, a_n \in \ttt T$, una lista $\ttt{List <T>}$ avente tali elementi può essere rappresentata come segue: $$\ttt [ a_1, \ldots, a_n \ttt ]$$
    \end{frameddefn}

    \begin{frameddefn}{Algebra delle liste finite}
        L'\tbf{algebra delle liste finite} è definita come segue: $$(\ttt{List<T>}, \mathrm{empty}, \mathrm{cons})$$ dove i costruttori sono i seguenti: $$\centeredsoe{\funcmap{\mathrm{empty}}{\1}{\ttt{List<T>}}{x}{\ttt{[]}} \\ \funcmap{\mathrm{cons}}{\ttt{List<T>} \times \ttt{T}}{\ttt{List<T>}}{(\ttt [ a_1, \ldots, a_n \ttt ], x)}{\ttt [ a_1, \ldots, a_n , x \ttt ]}}$$
    \end{frameddefn}

    \begin{framedprop}{Liste finite induttive}
        L'algebra delle liste finite è induttiva.
    \end{framedprop}

    \begin{proof}
        Si noti che:

        \begin{itemize}
            \item $\mathrm{empty}$ ha dominio in $\1$, e poiché contiene un solo elemento, $\mathrm{empty}$ è necessariamente iniettiva;
            \item $\forall l, l' \in \ttt{List<T>}, x, x' \in \ttt{T} \quad \mathrm{cons}(l, x) = \mathrm{cons}(l', x') \implies \soe{l}{l = l' \\ x = x'}$ altrimenti si avrebbero avute liste di lunghezze diverse, oppure liste contenenti diversi elementi;
            \item $\im{(\mathrm{empty})} \cap \im{(\mathrm{cons})} = \varnothing$, poiché solo $\mathrm{empty}$ può restituire $\ttt [ \ttt ]$, in quanto $\mathrm{cons}$ restituisce sempre una lista contenente almeno l'elemento fornito in input;
            \item sia $S \subseteq \ttt{List<T>}$ tale da essere chiuso rispetto a $\mathrm{cons}$, e contenente la lista vuota; per assurdo, sia $\ttt{List<T>} - S \neq \varnothing \implies \exists l \in \ttt{List<T>} - S$, ma $\ttt{List<T>}$ è chiuso rispetto a $\mathrm{cons}$, ed in particolare $\exists x \in \ttt{T}, l' \in \ttt{List<T>} \mid \mathrm{cons}(l', x) = l$, ma poichè $l \notin S$, allora necessariamente $l' \notin S$; ripetendo tale ragionamento ricorsivamente, si ottiene che $\ttt{[]} \notin \ttt{List<T>}$ $\lightning$.
        \end{itemize}
    \end{proof}

    \begin{framedobs}[label={infinite lists}]{Algebra delle liste infinite}
        Se all'algebra delle liste finite vengono aggiunte anche le liste infinite, l'algebra risultante non è induttiva, in quanto contiene l'algebra delle liste finite, la quale è induttiva, e viene dunque contraddetto il terzo assioma della \cref{inductive algebra}.
    \end{framedobs}

    \begin{framedobs}{Concatenazione di liste finite}
        È possibile estendere l'algebra delle liste finite per supportare l'operazione di concatenazione tra liste, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{concat}}{\ttt{List<T>} \times \ttt{List<T>}}{\ttt{List<T>}}{(l, l')}{\soe{ll}{l' & l = \ttt{[]} \\ \mathrm{cons}(n, \mathrm{concat}(t, l')) & \exists x \in \ttt T, t \in \ttt{List<T>} \mid l = \mathrm{cons}(t, x)}}$}
    \end{framedobs}

    \subsection{Alberi binari}

    \begin{frameddefn}{Albero binario}
        Un \tbf{albero binario} è una struttura dati che è possibile rappresentare graficamente come segue:

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[
                level distance=1cm,
                level 1/.style={sibling distance=2cm},
                level 2/.style={sibling distance=1cm}
            ]
                \node {$\circ$}
                    child {node {$\circ$}
                    child {node {$\circ$}}
                    child {node {$\circ$}}
                }
                    child {node {$\circ$}
                };
            \end{tikzpicture}
        \end{figure}

        Il primo nodo, poiché non è figlio di nessuno, è detto \tbf{radice}, e poiché l'albero è \tit{binario}, ogni nodo ha 0, nel qual caso è definito \tbf{foglia}, oppure 2 figli. L'insieme degli alberi binari viene denotato con \ttt{B-tree}.
    \end{frameddefn}

    \begin{frameddefn}{Algebra degli alberi binari finiti}
        L'\tbf{algebra degli alberi binari finiti} è definita come segue: $$(\ttt{B-tree}, \mathrm{leaf}, \mathrm{branch})$$ dove i costruttori sono i seguenti: $$\centeredsoe{\funcmap{\mathrm{leaf}}{\1}{\ttt{B-tree}}{x}{\circ} \\ \funcmap{\mathrm{branch}}{\ttt{B-tree} \times \ttt{B-tree}}{\ttt{B-tree}}{(b, b')}{
            \begin{tikzpicture}[
                level distance=1cm,
                level 1/.style={sibling distance=1cm},
            ]
                \node {$\circ$}
                    child {node {$b$}
                }
                    child {node {$b'$}
                };
            \end{tikzpicture}
        }}$$
    \end{frameddefn}

    \begin{framedprop}{Alberi binari finiti induttivi}
        L'algebra degli alberi binari finiti è induttiva.
    \end{framedprop}

    \begin{proof}
        Omessa.
    \end{proof}

    \begin{framedobs}{Algebra degli alberi binari infiniti}
        Analogamente all'\cref{infinite lists}, l'algebra degli alberi binari finiti ed infiniti non è induttiva.
    \end{framedobs}

    \begin{framedobs}{Foglie di un albero binario finito}
        È possibile estendere l'algebra degli alberi binari finiti per supportare l'operazione per contare i nodi di un albero, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{nodes}}{\ttt{B-tree}}{\N}{b}{\soe{ll}{1 & b = \circ \\ 1 + \mathrm{nodes}(t) + \mathrm{nodes}(t')  & \exists t, t' \in \ttt{B-tree} \mid b = \mathrm{branch}(t, t')}}$}
    \end{framedobs}

    \begin{framedobs}{Foglie di un albero binario finito}
        È possibile estendere l'algebra degli alberi binari finiti per supportare l'operazione per contare le foglie di un albero, come segue: $$\funcmap{\mathrm{leaves}}{\ttt{B-tree}}{\N}{b}{\soe{ll}{1 & b = \circ \\ \mathrm{leaves}(t) + \mathrm{leaves}(t') & \exists t, t' \in \ttt{B-tree} \mid b = \mathrm{branch}(t, t')}}$$
    \end{framedobs}

    \begin{framedthm}{Relazione tra foglie e nodi}
        Ogni albero binario finito, avente $n$, foglie ha $2n - 1$ nodi.
    \end{framedthm}

    \proofind{
        La seguente dimostrazione procede per \tit{induzione strutturale}, dunque effettuando l'induzione sulla morfologia della struttura dati, e non sul numero $n$ di foglie.
    }{
        Il caso base è costituito dunque da $\circ$, l'albero ottenuto attraverso il costruttore $\mathrm{leaf}$, ed infatti si ha che $$\mathrm{leaves}(\circ) = 1 \implies 2 \cdot 1 - 1 = 1$$ e $\circ$ ha esattamente 1 nodo.
    }{
        Un albero binario finito, avente $n$ nodi, ha $2n - 1$ foglie.
    }{
        Sia $b \in \ttt{B-tree}$ tale che esistano $t, t' \in \ttt{B-tree}$ tali che $\mathrm{branch}(t, t') = b$, e siano $$\soe{l}{\mathrm{leaves}(t) = n \\ \mathrm{leaves}(t') = n'}$$ Si noti che, per ipotesi induttiva, si ha che $$\soe{l}{\mathrm{nodes}(t) = 2n - 1 \\ \mathrm{nodes}(t') = 2n' - 1}$$ ed inoltre, poiché $b = \mathrm{branch}(t, t')$, $b$ ha la forma seguente

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[
                level distance=1cm,
                level 1/.style={sibling distance=1cm},
            ]
                \node {$\circ$}
                    child {node {$t$}
                }
                    child {node {$t'$}
                };
            \end{tikzpicture}

        \end{figure}
        dunque, per definizione di $\mathrm{leaves}$ si ha che $$\mathrm{leaves}(b) = \mathrm{leaves}(t) + \mathrm{leaves}(t') = n + n'$$ e, dalla morfologia di $b$, segue che $$\mathrm{nodes}(b) = \mathrm{nodes}(t) + \mathrm{notes}(t') + 1 = 2n -1 + 2n'-1 + 1 = 2(n + n') - 1$$ ed è quindi verificata la tesi, poiché $$\mathrm{leaves}(b) = n + n' \implies \mathrm{nodes}(b) = 2(n + n') - 1$$
    }
    
    \section{Sintassi astratta}
    
    \subsection{Definizioni}

    \begin{frameddefn}{Grammatica}
        Una \tbf{grammatica} è un insieme di regole, dette \tbf{termini}, che definiscono come poter manipolare un insieme di stringhe; una grammatica $G$, composta dai termini $A$, $B$ e $C$ è rappresentata come segue $$G ::= A \ | \ B \ | \ C$$
    \end{frameddefn}

    \begin{example}[Exp]
        \label{exp}
        Si consideri la seguente grammatica: $$Exp ::= \ttt 0 \ | \ \ttt 1 \ | \ldots \ | \ Exp + Exp \ | \ Exp * Exp$$ essa definisce le regole per utilizzare i numeri in $\N$, ammettendo inoltre le operazioni \und{sintattiche} di $+$ e $*$.
    \end{example}

    \begin{frameddefn}{Linguaggio di una grammatica}
        Sia $G$ una grammatica; allora, il \tbf{linguaggio di $G$} è l'insieme delle stringhe che è possibile costruire attraverso le regole dettate da $G$.
    \end{frameddefn}

    % \begin{example}[Linguaggio di Exp]
        

\end{document}
