\documentclass[a4paper, 12pt]{report}

%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage{../Nyx/nyx-packages}
\usepackage{../Nyx/nyx-styles}
\usepackage{../Nyx/nyx-frames}
\usepackage{../Nyx/nyx-title}
\usepackage{../Nyx/nyx-macros}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{../Nyx/logo.png}

\institute{\curlyquotes{\hspace{0.25mm}Sapienza} Università di Roma}
\faculty{Ingegneria dell'Informazione,\\Informatica e Statistica}
\department{Dipartimento di Informatica}

\title{Linguaggi di Programmazione}
\subtitle{Appunti integrati con il libro "TODO", TODO 1, Autore 2, ...}

% \author{\textit{Author}\\TODO: DECOMMENTARE QUESTA SEZIONE}
% \author{\textit{Author}\\Simone Bianco}
\author{\textit{Author}\\Alessio Bandiera}
% \supervisor{Linus \textsc{Torvalds}}
% \context{Well, I was bored\ldots}

\date{\today}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
    \maketitle

    % The following style changes are valid only inside this scope 
    {
        \hypersetup{allcolors=black}
        \fancypagestyle{plain}{%
        \fancyhead{}        % clear all header fields
        \fancyfoot{}        % clear all header fields
        \fancyfoot[C]{\thepage}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}}

        \romantableofcontents
    }

    \chapter*{Informazioni e Contatti}      % \chapter* makes this a "fake" chapter
    \markboth{Informazioni e Contatti}{}    % Manually sets \leftmark (current chapter name)
    \addcontentsline{toc}{chapter}{Informazioni e Contatti}     % Manually adds chapter to ToC
    
    \subsubsection{Prerequisiti consigliati:}
    \begin{itemize}
        \item Algebra
        \item TODO
    \end{itemize}

    \quad

    \subsubsection{Segnalazione errori ed eventuali migliorie:}
    
    Per segnalare eventuali errori e/o migliorie possibili, si prega di utilizzare il \textbf{sistema di Issues fornito da GitHub} all'interno della pagina della repository stessa contenente questi ed altri appunti (link fornito al di sotto), utilizzando uno dei template già forniti compilando direttamente i campi richiesti.

    Gli appunti sono in continuo aggiornamento, pertanto, previa segnalazione, si prega di controllare se l'errore sia ancora presente nella versione più recente.

    \quad

    \subsubsection{Licenza di distribuzione:}
    
    These documents are distributed under the \textbf{\href{https://www.gnu.org/licenses/fdl-1.3.txt}{GNU Free Documentation License}}, a form of copyleft intended to be used on manuals, textbooks or other types of document in order to assure everyone the effective freedom to copy and redistribute it, with or without modifications, either commercially or non-commercially.
    
    \quad

    \subsubsection{Contatti dell'autore e ulteriori link:}
    \begin{itemize}
        % \item TODO: DECOMMENTARE QUESTA SEZIONE

        % Simone
        % 
        % \item Altri appunti: \textbf{\href{https://github.com/Exyss/university-notes}{https://github.com/Exyss/university-notes}}
        % \item Github: \textbf{\href{https://github.com/Exyss}{https://github.com/Exyss}}
        % \item Email: \textbf{\href{mailto:bianco.simone@outlook.it}{bianco.simone@outlook.it}}
        % \item LinkedIn: \textbf{\href{https://www.linkedin.com/in/simone-bianco}{Simone Bianco}}

        % Alessio
        % 
        \item Github: \textbf{\href{https://github.com/ph04}{https://github.com/ph04}}
        \item Email: \textbf{\href{mailto:alessio.bandiera02@gmail.com}{alessio.bandiera02@gmail.com}}
        \item LinkedIn: \textbf{\href{https://www.linkedin.com/in/alessio-bandiera-a53767223/}{Alessio Bandiera}}
    \end{itemize}

    %%%%%%%%%%%%%%%%%%%%%

    \chapter{Induzione}
    
    \section{Algebre induttive}

    \subsection{Assiomi di Peano}

    \begin{frameddefn}[label={peano}]{Assiomi di Peano}
        Gli \tbf{assiomi di Peano} sono 5 assiomi che definiscono l'insieme $\N$, e sono i seguenti:

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $0 \in \N$
            \item $\exists \func{\mathrm{succ}}{\N}{\N}$, o equivalentemente, $\forall x \in \N \quad \mathrm{succ}(x) \in \N$
            \item $\forall x, y \in \N \quad x \neq y \implies \mathrm{succ}(x) \neq \mathrm{succ}(y)$
            \item $\nexists x \in \N \mid \mathrm{succ}(x) = 0$
            \item $\forall S \subseteq \N \quad (0 \in S \land (\forall x \in S \quad \mathrm{succ}(x) \in S)) \implies S = \N$
        \end{enumerate}
    \end{frameddefn}

    \begin{example}[$\N$ di von Neumann]
        Una rappresentazione dell'insieme dei numeri naturali $\N$ alternativa alla canonica $$\N := \{0, 1, 2, \ldots \}$$ è stata fornita da John von Neumann. Indicando tale rappresentazione con $\aleph$, si ha che, per Neumann $$\begin{array}{c} 0_\aleph := \varnothing  = \{\} \\ 1_\aleph := \{ 0_\aleph \} = \{ \{ \}\} \\ 2_\aleph := \{0_\aleph, 1_\aleph\} = \{\{\}, \{\{ \}\}\} \\ \vdots \end{array}$$ e la funzione $\mathrm{succ}_\aleph$ è definita come segue $$\funcmap{\mathrm{succ}_\aleph}{\aleph}{\aleph}{x_\aleph}{x_\aleph \cup \{x_\aleph\} = \{\mu_\aleph \in \aleph \mid |\mu_\aleph| \le |x_\aleph|\}}$$ ed in particolare $\forall x_\aleph \in \aleph \quad |x_\aleph| + 1 = |\mathrm{succ}_\aleph(x_\aleph)|$.

        È possibile verificare che tale rappresentazione di $\N$ soddisfa gli assiomi di Peano, in quanto

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $0_\aleph := \varnothing \in \aleph$;
            \item $\exists \func{\mathrm{succ}_\aleph}{\aleph}{\aleph}$, definita precedentemente;
            \item $\forall x_\aleph, y_\aleph \in \aleph \quad x_\aleph \neq y_\aleph \implies |x_\aleph| \neq |y_\aleph| \implies  |\mathrm{succ}_\aleph(x_\aleph)| \neq |\mathrm{succ}_\aleph(y_\aleph)| \implies \mathrm{succ}_\aleph(x_\aleph) \neq \mathrm{succ}_\aleph(y_\aleph)$;
            \item per assurdo, sia $x_\aleph \in \aleph$ tale che $\mathrm{succ}_\aleph(x_\aleph) = 0_\aleph := \varnothing$; per definizione $\mathrm{succ}_\aleph(x_\aleph) := \{\mu_\aleph \in \aleph \mid |\mu_\aleph| \le |x_\aleph|\}$, ma non esiste $\mu_\aleph \in \aleph$ con cardinalità minore o uguale 0, e dunque $\nexists x_\aleph \in \aleph \mid \mathrm{succ}_\aleph(x_\aleph) = 0_\aleph$;
            \item per assurdo, sia $S \subseteq \aleph$ tale che $0_\aleph \in S$ e $\forall x_S \in S \quad \mathrm{succ}_\aleph(x_S) \in S$ ma $S \neq \aleph \iff \aleph - S \neq \varnothing \implies \exists \zeta_\aleph \in \aleph - S$, ed in particolare $\zeta_\aleph \neq 0_\aleph$; $\aleph$ è chiuso su $\mathrm{succ}_\aleph$ per il secondo assioma di Peano, e dunque $\zeta_\aleph \neq 0_\aleph \implies \exists \zeta'_\aleph \in \aleph \mid \mathrm{succ}_\aleph(\zeta'_\aleph) = \zeta_\aleph$, e sicuramente $\zeta'_\aleph \notin S$, poiché altrimenti $\zeta_\aleph \in S$ anch'esso in quanto $S$ è chiuso rispetto a $\mathrm{succ}_\aleph$; allora, ripetendo il ragionamento analogo per l'intera catena di predecessori, $S$ risulterebbe essere vuoto, ma ciò è impossibile poiché $0_\aleph \in S$ in ipotesi $\lightning$.
        \end{enumerate}
    \end{example}

    \begin{framedprinc}[label={induction}]{Principio di Induzione}
        Sia $P$ una proprietà che vale per $n = 0$, e dunque $P(0)$ è vera; inoltre,  per ogni $n \in \N$ si ha che $P(n) \implies P(n + 1)$; allora, $P(n)$ è vera per ogni $n \in \N$.

        In simboli, utilizzando la notazione della logica formale, si ha che $$\dfrac{P(0) \land (\forall n \in \N \quad P(n) \implies P(n + 1))}{\forall n \in \N \quad P(n)}$$
    \end{framedprinc}

    \begin{framedobs}{Quinto assioma di Peano}
        Si noti che il quinto degli assiomi di Peano (\cref{peano}) equivale al principio di induzione (\cref{induction}). Infatti, il quinto assioma afferma che qualsiasi sottoinsieme $S$ di $\N$ avente lo 0, e caratterizzato dalla chiusura sulla funzione di successore $\mathrm{succ}$, coincide con $\N$ stesso.
    \end{framedobs}

    \subsection{Algebre induttive}

    \begin{frameddefn}{Algebra}
        Una \tbf{struttura algebrica}, o più semplicemente \tbf{algebra}, consiste di un insieme \tit{non vuoto}, talvolta chiamato \tbf{insieme sostegno} (\tit{carrier set} o \tit{domain}), fornito di una o più operazioni su tale insieme, quest'ultime caratterizzate da un numero finito di assiomi da soddisfare.

        Se $A$ è il carrier set, e $\gamma_1, \ldots \gamma_n$ sono delle operazioni definite su $A$, allora con $$(A, \gamma_1, \ldots, \gamma_n)$$ si indica l'algebra costituita da tali componenti.
    \end{frameddefn}

    \begin{example}[Strutture algebriche con singola operazione]
        Esempi di strutture algebriche con un'operazione binaria sono i seguenti:

        \begin{itemize}
            \item semigruppi
            \item monoidi
            \item gruppi
            \item gruppi abeliani
        \end{itemize}
    \end{example}

    \begin{example}[Strutture algebriche con due operazioni]
        Esempi di strutture algebriche con due operazioni binarie sono i seguenti:

        \begin{itemize}
            \item semianelli
            \item anelli
            \item campi
        \end{itemize}
    \end{example}

    \begin{frameddefn}{Insieme unità}
        Con \tbf{insieme unità} verrà inteso un qualsiasi insieme tale che $\abs{\1} = 1$, e verrà indicato attraverso il simbolo $\1$.
    \end{frameddefn}

    \begin{frameddefn}[label={inductive algebra}]{Algebra induttiva}
        Sia $A$ un insieme, e siano $\gamma_1, \ldots, \gamma_n$ funzioni definite su $A$ di arbitraria arietà; allora, $(A, \gamma_1, \ldots, \gamma_n)$ è definita \tbf{algebra induttiva} se si verificano le seguenti:

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $\gamma_1, \ldots, \gamma_n$ sono iniettive
            \item $\forall i, j \in [1, n] \mid i \neq j \quad \im(\gamma_i) \cap \im(\gamma_j) = \varnothing$, ovvero, le immagini dei costruttori sono a due a due disgiunte
            \item $\forall S \subseteq A \quad (\forall i \in [1, n], a_1, \ldots a_k \in S, k \in \N  \quad \gamma_i(a_1, \ldots, a_k) \in S) \implies S = A$, o equivalentemente, in $A$ non devono essere contenute algebre induttive.
        \end{enumerate}

        Le funzioni $\gamma_1, \ldots, \gamma_n$ prendono il nome di \tbf{costruttori dell'algebra}.
    \end{frameddefn}

    \begin{framedobs}[label={third inductive algebra}]{Terzo assioma delle algebre induttive}
        Si noti che nel terzo assioma della \cref{inductive algebra} anche $S = \varnothing$ è un valido sottoinsieme di $A$, ma poiché non esistono $a_1, \ldots, a_k \in \varnothing$, in esso ogni qualificazione è vera a vuoto. Di conseguenza, nel momento in cui si ammette $S = \varnothing$ nel terzo assioma, l'algebra risulta essere non induttiva necessariamente (a meno dell'algebra vuota).
        
        Di conseguenza, questo terzo assioma forza la necessità della presenza di un costruttore unitario all'interno di ogni algebra induttiva, in modo da non poter ammettere $S = \varnothing$, poiché l'algebra deve essere chiusa su ognuno dei suoi costruttori.
    \end{framedobs}

    \begin{example}[Numeri naturali]
        $(\N, +)$ non è un algebra induttiva, poiché esistono $x_1, x_2, x_3, x_4 \in \N$ con $x_1 \neq x_3$ e $x_2 \neq x_4$ tali che $x_1 + x_2 = x_3 + x_4$; ad esempio, 2 + 3 = 5 = 1 + 4, e 2 $\neq$ 1, 3 $\neq$ 4.
    \end{example}

    \begin{example}[Algebra di Boole]
        Dato l'insieme $B = \{ \mathrm{true}, \mathrm{false}\}$, e la funzione $\lnot$ definita come segue $$\funcmap{\lnot}{B}{B}{x}{\left \{ \begin{array}{ll} \mathrm{false} & x = \mathrm{true} \\ \mathrm{true} & x = \mathrm{false} \end{array} \right.}$$ è possibile dimostrare che l'algebra $(B, \lnot)$ non è induttiva; infatti, nonostante $\lnot$ sia iniettiva, e la seconda proprietà della \cref{inductive algebra} sia vera a vuoto, $(B, \lnot)$ non presenta costruttore unitario, e dunque non può costituire un'algebra induttiva (si noti l'\cref{third inductive algebra}).
    \end{example}

    \begin{example}[Algebre induttive]
        Sia $\mathrm{zero}$ la funzione definita come segue $$\funcmap{\mathrm{zero}}{\1}{\N}{x}{0}$$ e si prenda in esame l'algebra $(\N, \mathrm{succ}, \mathrm{zero})$; allora si ha che

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $\mathrm{succ}$ e $\mathrm{zero}$ sono iniettive, poiché
                \begin{itemize}
                    \item $\mathrm{succ}$ è iniettiva per il terzo assioma di Peano (\cref{peano})
                    \item $\forall x, y \in \1 \quad \mathrm{zero}(x) = \mathrm{zero}(y) \implies x = y$ poiché $x, y \in \1 \implies x = y$ in quanto $\abs{\1} = 1$
                \end{itemize}
            \item $\im(\mathrm{succ}) \cap \im(\mathrm{zero}) = \left(\N - \{0\}\right) \cap \{0\} = \varnothing$
            \item TODO
        \end{enumerate}
    \end{example}

    \begin{frameddefn}{Omomorfismo}
        Un \tbf{omomorfismo} è una funzione, tra due algebre dello stesso tipo, tale da preservarne le strutture.

        Formalmente, siano $(A, \mu_1, \ldots, \mu_n)$ e $(B, \delta_1, \ldots, \delta_n)$ due algebre tali che ogni funzione $\mu_i$ abbia la stessa arietà e lo stesso numero di parametri esterni (denotati con $k$) di $\delta_i$, pari rispettivamente ad $\eta_i$ ed a $\nu_i$, per qualche $i \in [1, n]$; allora, una funzione $\func{f}{A}{B}$ è detta essere un \tbf{omomorfismo} tra le due algebre, se e solo se $$\begin{array}{c} \forall a_1, \ldots, a_{\eta_1} \quad f(\mu_1(a_1, \ldots, a_{\eta_n}), k_1, \ldots, k_{\nu_1}) = \delta_1(f(a_1), \ldots, f(a_{\eta_1}), k_1, \ldots, k_{\nu_1}) \\ \vdots \\ \forall a_1, \ldots, a_{\eta_n} \quad f(\mu_n(a_1, \ldots, a_{\eta_n}), k_1, \ldots, k_{\nu_n}) = \delta_n(f(a_1), \ldots, f(a_{\eta_n}), k_1, \ldots, k_{\nu_n}) \end{array}$$
    \end{frameddefn}

    \begin{example}[Omomorfismi]
        \label{homo}
        Si considerino i gruppi $(\R, +)$ e $(\R_{> 0}, \cdot)$, e sia $f$ definita come segue: $$\funcmap{f}{\R}{\R_{> 0}}{x}{e^x}$$ allora, si ha che $$\forall x, y \in \R \quad f(x) \cdot f(y) = e^x \cdot e^y = e^{x + y} = f(x + y)$$ dunque $f$ è un omomorfismo di gruppi.
    \end{example}

    \begin{frameddefn}{Isomorfismo}
        Un \tbf{isomorfismo} è un omomorfismo biettivo.
    \end{frameddefn}

    \begin{example}[Isomorfismi]
        Si consideri l'omomorfismo dell'\cref{homo}; si noti che $$\forall x, y \in \R \mid x \neq \R \quad e^x \neq e^y \implies f(x) \neq f(y)$$ e dunque $f$ è iniettiva; inoltre $$\forall y \in \R_{> 0} \quad \exists x \in \R \mid f(x) = e^x = y \iff y = \ln(x)$$ e dunque $f$ è suriettiva. Allora, $f$ è biettiva, e poiché è un omomorfismo, risulta essere un isomorfismo.
    \end{example}

    \section{Strutture dati induttive}

    \subsection{Liste}

    \begin{frameddefn}{Liste}
        Una \tbf{lista} è una collezione ordinata di elementi, e l'insieme delle liste di lunghezza finita viene denotato con $\ttt{List<T>}$, dove $\ttt T$ è il tipo degli elementi che le liste contengono, ed il simobolo $\ttt T$ verrà identificato con l'insieme di tutti gli oggetti aventi tipo $\ttt T$.

        Dati $a_1, \ldots, a_n \in \ttt T$, una lista $l \in \ttt{List<T>}$ contenente tali elementi può essere rappresentata come segue: $$\ttt [ a_1, \ldots, a_n \ttt ]$$
    \end{frameddefn}

    \begin{frameddefn}{Algebra delle liste finite}
        L'\tbf{algebra delle liste finite} è definita come segue: $$(\ttt{List<T>}, \mathrm{empty}, \mathrm{cons})$$ dove i costruttori sono i seguenti: $$\centeredsoe{\funcmap{\mathrm{empty}}{\1}{\ttt{List<T>}}{x}{\ttt{[]}} \\ \funcmap{\mathrm{cons}}{\ttt{List<T>} \times \ttt{T}}{\ttt{List<T>}}{(\ttt [ a_1, \ldots, a_n \ttt ], x)}{\ttt [ a_1, \ldots, a_n , x \ttt ]}}$$
    \end{frameddefn}

    \begin{framedprop}[label={alf induttiva}]{Liste finite induttive}
        L'algebra delle liste finite è induttiva.
    \end{framedprop}

    \begin{proof}
        Si noti che:

        \begin{itemize}
            \item $\mathrm{empty}$ ha dominio in $\1$, e poiché questo contiene un solo elemento, $\mathrm{empty}$ è necessariamente iniettiva;
            \item $\forall l, l' \in \ttt{List<T>}, x, x' \in \ttt{T} \quad \mathrm{cons}(l, x) = \mathrm{cons}(l', x') \implies \soe{l}{l = l' \\ x = x'}$ altrimenti $l$ ed $l'$ avrebbero avuto lunghezze diverse, oppure avrebbero contenuto diversi elementi;
            \item $\im{(\mathrm{empty})} \cap \im{(\mathrm{cons})} = \varnothing$, poiché solo $\mathrm{empty}$ può restituire $\ttt [ \ttt ]$, in quanto $\mathrm{cons}$ restituisce sempre una lista contenente almeno l'elemento fornito in input;
            \item sia $S \subseteq \ttt{List<T>}$ tale da essere chiuso rispetto a $\mathrm{cons}$, e contenente la lista vuota; per assurdo, sia $\ttt{List<T>} - S \neq \varnothing \implies \exists l \in \ttt{List<T>} - S$, ma $\ttt{List<T>}$ è chiuso rispetto a $\mathrm{cons}$, ed in particolare $\exists x \in \ttt{T}, l' \in \ttt{List<T>} \mid \mathrm{cons}(l', x) = l$, ma poichè $l \notin S$, allora necessariamente $l' \notin S$, poiché $S$ è chiuso rispetto a $\mathrm{cons}$, e quindi $l' \in S \implies l \in S$, ma $l$ è stato scelto in $\ttt{List<T>} - S$; ripetendo tale ragionamento induttivamente, si ottiene che $S$ è vuoto, ma questo è impossibile poiché $\ttt{[]} \in \ttt{List<T>}$ in ipotesi $\lightning$.
        \end{itemize}

        Dunque, l'algebra delle liste finite risulta essere induttiva.
    \end{proof}

    \begin{framedobs}[label={infinite lists}]{Algebra delle liste infinite}
        Se all'algebra delle liste finite venissero aggiunte anche le liste infinite, l'algebra risultante non sarebbe induttiva, in quanto conterrebbe l'algebra delle liste finite, la quale è induttiva per la \cref{alf induttiva}, e verrebbe dunque contraddetto il terzo assioma della \cref{inductive algebra}.
    \end{framedobs}

    \begin{framedobs}{Concatenazione di liste finite}
        È possibile estendere l'algebra delle liste finite per supportare l'operazione di concatenazione tra liste, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{concat}}{\ttt{List<T>} \times \ttt{List<T>}}{\ttt{List<T>}}{(l, l')}{\soe{ll}{l' & l = \ttt{[]} \\ \mathrm{cons}(x, \mathrm{concat}(t, l')) & \exists x \in \ttt T, t \in \ttt{List<T>} \mid l = \mathrm{cons}(t, x)}}$}
    \end{framedobs}

    \subsection{Alberi binari}

    \begin{frameddefn}{Albero binario}
        Un \tbf{albero binario} è una struttura dati che è possibile rappresentare graficamente come segue:

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[
                    level distance=1cm,
                    level 1/.style={sibling distance=2cm},
                    level 2/.style={sibling distance=1cm}
                ]
                \node {$\circ$}
                    child {node {$\circ$}
                    child {node {$\circ$}}
                    child {node {$\circ$}}
                }
                    child {node {$\circ$}
                };
            \end{tikzpicture}
        \end{figure}

        Il primo nodo, poiché non è figlio di nessuno, è detto \tbf{radice}, e poiché l'albero è \tit{binario}, ogni nodo ha 0 --- nel qual caso è definito \tbf{foglia} --- oppure 2 figli. L'insieme degli alberi binari viene denotato con \ttt{B-tree}.
    \end{frameddefn}

    \begin{frameddefn}{Algebra degli alberi binari finiti}
        L'\tbf{algebra degli alberi binari finiti} è definita come segue: $$(\ttt{B-tree}, \mathrm{leaf}, \mathrm{branch})$$ dove i costruttori sono i seguenti:

        $$\funcmap{\mathrm{leaf}}{\1}{\ttt{B-tree}}{x}{\circ}$$

        \begin{center}
            \begin{tabular}{c c}
                \begin{tabular}{c}$\funcmap{\mathrm{branch}}{\ttt{B-tree} \times \ttt{B-tree}}{\ttt{B-tree}}{(b, b')}{}$\end{tabular}
                &
                \begin{tabular}{c}
                    \begin{tikzpicture}[
                            level distance=1cm,
                            level 1/.style={sibling distance=1cm},
                        ]
                        \node {$\circ$}
                            child {node {$b$}
                        }
                            child {node {$b'$}
                        };
                    \end{tikzpicture}
                \end{tabular}
            \end{tabular}
        \end{center}
    \end{frameddefn}

    \begin{framedprop}{Alberi binari finiti induttivi}
        L'algebra degli alberi binari finiti è induttiva.
    \end{framedprop}

    \begin{proof}
        Omessa.
    \end{proof}

    \begin{framedobs}{Algebra degli alberi binari infiniti}
        Analogamente all'\cref{infinite lists}, l'algebra degli alberi binari finiti ed infiniti non è induttiva.
    \end{framedobs}

    \begin{framedobs}{Nodi di un albero binario finito}
        È possibile estendere l'algebra degli alberi binari finiti per supportare l'operazione per contare i nodi di un albero, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{nodes}}{\ttt{B-tree}}{\N}{b}{\soe{ll}{1 & b = \circ \\ 1 + \mathrm{nodes}(t) + \mathrm{nodes}(t')  & \exists t, t' \in \ttt{B-tree} \mid b = \mathrm{branch}(t, t')}}$}
    \end{framedobs}

    \begin{framedobs}{Foglie di un albero binario finito}
        È possibile estendere l'algebra degli alberi binari finiti per supportare l'operazione per contare le foglie di un albero, come segue: $$\funcmap{\mathrm{leaves}}{\ttt{B-tree}}{\N}{b}{\soe{ll}{1 & b = \circ \\ \mathrm{leaves}(t) + \mathrm{leaves}(t') & \exists t, t' \in \ttt{B-tree} \mid b = \mathrm{branch}(t, t')}}$$
    \end{framedobs}

    \begin{framedthm}{Relazione tra foglie e nodi}
        Ogni albero binario finito, avente $n$ foglie, ha $2n - 1$ nodi.
    \end{framedthm}

    \proofind{
        La seguente dimostrazione procede per \tit{induzione strutturale}, dunque effettuando l'induzione sulla morfologia della struttura dati, e non sul numero $n$ di foglie.
    }{
        Il caso base è costituito dunque da $\circ$, l'albero ottenuto attraverso il costruttore unitario $\mathrm{leaf}$, ed infatti si ha che $$\mathrm{leaves}(\circ) = 1 \implies 2 \cdot 1 - 1 = 1$$ e $\circ$ ha esattamente 1 nodo.
    }{
        Un albero binario finito, avente $n$ foglie, ha $2n - 1$ nodi.
    }{
        Sia $b \in \ttt{B-tree}$ tale che esistano $t, t' \in \ttt{B-tree}$ tali che $\mathrm{branch}(t, t') = b$, e siano $$\soe{l}{\mathrm{leaves}(t) = n \\ \mathrm{leaves}(t') = n'}$$ Si noti che, per ipotesi induttiva, si ha che $$\soe{l}{\mathrm{nodes}(t) = 2n - 1 \\ \mathrm{nodes}(t') = 2n' - 1}$$ ed inoltre, poiché $b = \mathrm{branch}(t, t')$, $b$ ha la forma seguente

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[
                    level distance=1cm,
                    level 1/.style={sibling distance=1cm},
                ]
                \node {$\circ$}
                    child {node {$t$}
                }
                    child {node {$t'$}
                };
            \end{tikzpicture}

        \end{figure}
        dunque, per definizione di $\mathrm{leaves}$ si ha che $$\mathrm{leaves}(b) = \mathrm{leaves}(t) + \mathrm{leaves}(t') = n + n'$$ e, dalla morfologia di $b$, segue che $$\mathrm{nodes}(b) = \mathrm{nodes}(t) + \mathrm{notes}(t') + 1 = 2n -1 + 2n'-1 + 1 = 2(n + n') - 1$$ ed è quindi verificata la tesi, poiché $$\mathrm{leaves}(b) = n + n' \implies \mathrm{nodes}(b) = 2(n + n') - 1$$
    }
    
    \section{Sintassi astratta}
    
    \subsection{Grammatiche}

    \begin{frameddefn}{Grammatica}
        Una \tbf{grammatica} è un insieme di regole che definiscono come manipolare un insieme di stringhe, agendo su elementi sintattici detti \tbf{termini}.
    \end{frameddefn}

    \begin{frameddefn}{Forma di Backus-Naur (BNF)}
        La \tbf{forma di Backus-Naur} (\tit{Backus-Naur Form}) è una notazione utilizzata per descrivere la sintassi di grammatiche, ed è definita come segue: $$\ttt{<symbol>}, \ldots, \ttt{<symbol>} ::= \ttt{\_expression\_} \ | \ \ldots \ | \ \ttt{\_expression\_}$$ dove
        \begin{itemize}
            \item $\ttt{<symbol>}$ è una \tit{metavariabile non terminale}, ovvero, può essere sostituito con regole definite dalla grammatica; si noti che le regole possono essere utilizzate \und{ricorsivamente};
            \item il simbolo $::=$ indica che ciò che è posto alla sua sinistra deve essere sostituito con ciò che è alla sua destra;
            \item $\ttt{\_expression\_}$ è un espressione che verrà usata per rimpiazzare le metavariabili non terminali, attraverso le regole definite dalla grammatica; le \tit{metavarabili} che compongono le espressioni possono essere \tbf{costanti}, \tbf{variabili}, \tbf{termini} o \tbf{espressioni} contenenti combinazioni delle precedenti, presentando eventualmente anche operazioni sintattiche specifiche.
        \end{itemize}
    \end{frameddefn}

    \begin{example}[Grammatica $Exp$]
        \label{exp}
        Sia $Exp$ la seguente grammatica: $$M, N ::= \ttt 0 \ | \ \ttt 1 \ | \ldots \ | \ x \ | \ M \ \ttt + \ N \ | \ M \ \ttt * \ N$$ essa definisce le regole per utilizzare i numeri in $\N$, ammettendo inoltre le operazioni \und{sintattiche} di $\ttt +$ e $\ttt *$.

        All'interno di questa grammatica dunque, le metavariabili utilizzate sono le seguenti:
        \begin{itemize}
            \item \tit{costanti}: $\ttt 0, \ttt 1,  \ldots$
            \item \tit{variabili}: $x$
            \item \tit{termini}: $M$ ed $N$
            \item \tit{espressioni}: $M \ \ttt + \ N$ e $M \ \ttt * \ N$ (tecnicamente anche le precedenti sono espressioni, ma queste in particolare sfruttano operazioni sintattiche precise)
        \end{itemize}
    \end{example}

    \begin{frameddefn}{Variabili}
        Data una grammatica di $G$, con $\mathrm{Var}$ si indica l'\tbf{insieme delle variabili} di $G$.
    \end{frameddefn}

    \begin{frameddefn}{Valori}
        Data una grammatica, con $\mathrm{Val}$ si indica l'\tbf{insieme dei valori} che ogni termine della grammatica può assumere.
    \end{frameddefn}

    \begin{example}[Variabili e valori di $Exp$]
        Si prenda in considerazione la grammatica $Exp$ dell'\cref{exp2}; in essa, si ha che $$\centeredsoe{\mathrm{Var} = \{ x \} \\ \mathrm{Val} = \{ \ttt 0, \ttt 1, \ldots \}}$$
    \end{example}

    \begin{frameddefn}{Linguaggio di una grammatica}
        Sia $G$ una grammatica; allora, il \tbf{linguaggio di $G$} è l'insieme delle stringhe che è possibile costruire attraverso le regole dettate da $G$.
    \end{frameddefn}

    \begin{example}[Linguaggio di $Exp$]
        Si prenda in considerazione $Exp$, la grammatica definita all'interno dell'\cref{exp}; in essa, prendendo ad esempio le stringhe $\ttt{"4"}$ e $\ttt{"23"}$, si può ottenere la stringa $$\ttt{+}(\ttt{"4"}, \ttt{"23"}) = \ttt{"4 + 23"}$$ dove la \tit{polish notation} --- alla sinistra dell'uguale --- e la forma sintattica canonica --- alla sua destra --- verranno utilizzate intercambiabilmente, poiché puro \tit{syntactic sugar}.
    \end{example}

    \begin{framedobs}[label={eval}]{Valutazione di $Exp$}
        Si prenda in considerazione la grammatica $Exp$ dell'\cref{exp}; su di essa, è possibile definire ricorsivamente una funzione $\mathrm{eval}$, in grado di valutare le stringhe che tale grammatica può produrre, come segue: $$\centeredsoe{\mathrm{eval}(\ttt 0) = \ttt 0 \\ \mathrm{eval}(\ttt 1) = \ttt 1 \\ \vdots \\ \mathrm{eval}(M \ \ttt + \ N) = \mathrm{eval}(M) \ \ttt + \ \mathrm{eval}(N) \\ \mathrm{eval}(M \ \ttt * \ N) = \mathrm{eval}(M) \ \ttt * \ \mathrm{eval}(N)}$$
    \end{framedobs}

    \begin{framedobs}[label={ambiguity}]{Ambiguità di $Exp$}
        Si prenda in considerazione la grammatica $Exp$ dell'\cref{exp}; si noti che tale grammatica è ambigua, poichè ad esempio $$\ttt{+}(\ttt{"5"}, \ttt{*}(\ttt{"6"}, \ttt{"7"})) = \ttt{"5 + 6 * 7"} = \ttt{*}(\ttt{+}(\ttt{"5"}, \ttt{"6"}), \ttt{"7"})$$ e da ciò segue anche che $\im{(\ttt+)} \cap \im{(\ttt *)} \neq \varnothing$.
    \end{framedobs}

    \begin{framedobs}{Disambiguazione di $Exp$}
        Si noti che l'ambiguità trattata nell'\cref{ambiguity} non permetterebbe di poter definire la funzione $\mathrm{eval}$, descritta nell'\cref{eval}. Dunque, per risolvere tale ambiguità, a meno di parentesi (che \tit{non} sono definite all'interno della grammatica) o dell'esplicitazione della composizione di funzioni utilizzata, verrà sottointesa la normale precedenza degli operatori aritmetica durante la valutazione delle stringhe.
    \end{framedobs}

    \subsection{Scoping}

    \begin{frameddefn}[label={let}]{Clausola $let$}
        Sia $G$ una grammatica; allora, è possibile definire su $G$ una funzione \tbf{$let$}, come segue: $$\func{let}{\mathrm{Var} \times G \times G}{G}$$ e verrà utilizzata attraverso la sintassi $$\letin{\ttt{*variable*}}{\ttt{\_expression\_}_1}{\ttt{\_expression\_}_2}$$ ed alla variabile $\ttt{*variable*}$ verrà assegnata l'espressione $\ttt{\_expression\_}_1$ \tit{durante la valutazione} di $\ttt{\_expression\_}_2$; la variabile $\ttt{*variable*}$, all'interno di $\ttt{\_expression\_}_2$, prende il nome di \tbf{variabile locale}.

        Una variabile alla quale non è stata assegnata nessuna espressione prende il nome di \tbf{variable libera} (\tit{unbound variable} in inglese); una variabile non libera è detta \tbf{variabile legata} (\tit{bound variable}).
    \end{frameddefn}
    
    \begin{example}[Estensione di $Exp$]
        \label{exp2}
        Sia $Exp$ un'estensione della grammatica presente all'interno dell'\cref{exp}, descritta come segue: $$M, N ::= k \ | \ x \ | \ M \ \ttt + \ N \ | \ M \ \ttt * \ N \ | \ \letin{x}{M}{N}$$

        In essa, sono presenti:

        \begin{itemize}
            \item \tit{costanti}: indicate con $k$, che sta ad indicare che in $Exp$ è ammessa qualsiasi costante; di fatto, è possibile pensare a $k$ come una funzione definita come segue: $$\funcmap{k}{\N}{Exp}{x}{\ttt{"x"}}$$
            \item \tit{variabili}: $x$
            \item \tit{termini}: $M$ ed $N$
            \item \tit{espressioni}: $M \ \ttt + \ N$, $M \ \ttt * \ N$ e $\letin{x}{M}{N}$
        \end{itemize}
    \end{example}

    \begin{example}[Clausole $let$]
        Sia $Exp$ la grammatica dell'\cref{exp2}; un esempio di espressione su $Exp$, che utilizza la clausola $let$ della \cref{let}, è la seguente: $$\letin{x}{3}{(x + 1)}$$ e nel momento in cui viene valutata tale espressione, si ha che $$x = 3 \implies x + 1 = 3 + 1 = 4$$ e dunque il valore dell'espressione è 4.
    \end{example}

    \begin{example}[Variabili libere]
        Sia $Exp$ la grammatica dell'\cref{exp2}, ed ammettendo la variabile $y$ in essa, si consideri la seguente espressione: $$\letin{x}{3}{(x + y)}$$ in essa, la variabile $x$ è posta pari a 3, ma ad $y$ non è stato assegnato alcun valore, e dunque risulta essere una variabile libera.
    \end{example}

    \begin{framedobs}{Variabili libere di un'espressione}
        Sia $Exp$ la grammatica dell'\cref{exp2}; su di essa, è possibile definire, ricorsivamente, una funzione in grado di restituire le variabili unbound di una data espressione, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{free}}{Exp}{\powerset{\left(Var\right)}}{e}{\soe{ll}{
            \varnothing & \exists \eta \in \N \mid e = k(\eta) \\ 
            \{x\} & \exists x \in \mathrm{Var} \mid e = x \\ 
            \mathrm{free}(M) \cup \mathrm{free}(N) & \exists M, N \in Exp \mid e = M \ \ttt + \ N \lor e = M \ \ttt * \ N \\
            \mathrm{free}(M) \cup (\mathrm{free}(N) - \{x\}) & \exists x \in \mathrm{Var}, M, N \in Exp \mid e = \letin{x}{M}{N}
        }}$}
    \end{framedobs}

    \subsection{Ambienti}
    
    \begin{frameddefn}{Ambiente}
        Data una grammatica tale che $\mathrm{Val}$ sia un insieme finito, un \tbf{ambiente} è una funzione della forma $$\func{E}{\mathrm{Var}}{\mathrm{Val}}$$ che associa dunque una variabile, ad un possibile valore che può assumere con espressioni della grammatica di riferimento. L'insieme di tutti gli ambienti della grammatica è denotato con $\mathrm{Env}$.

        In simboli, gli ambienti verranno scritti come insiemi di coppie $(x, k)$ con $x \in \mathrm{Var}, k \in \mathrm{Val}$, che descriveranno la mappa definita dall'ambiente stesso.
    \end{frameddefn}

    % \begin{frameddefn}

\end{document}
