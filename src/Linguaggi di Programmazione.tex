\documentclass[a4paper, 12pt]{report}

%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage{../Nyx/nyx-packages}
\usepackage{../Nyx/nyx-styles}
\usepackage{../Nyx/nyx-frames}
\usepackage{../Nyx/nyx-title}
\usepackage{../Nyx/nyx-macros}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{../Nyx/logo.png}

\institute{\curlyquotes{\hspace{0.25mm}Sapienza} Università di Roma}
\faculty{Ingegneria dell'Informazione,\\Informatica e Statistica}
\department{Dipartimento di Informatica}

\title{Linguaggi di Programmazione}
\subtitle{Appunti integrati con il libro "TODO", TODO 1, Autore 2, ...}

% \author{\textit{Author}\\TODO: DECOMMENTARE QUESTA SEZIONE}
% \author{\textit{Author}\\Simone Bianco}
\author{\textit{Author}\\Alessio Bandiera}
% \supervisor{Linus \textsc{Torvalds}}
% \context{Well, I was bored\ldots}

\date{\today}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
    \maketitle

    % The following style changes are valid only inside this scope 
    {
        \hypersetup{allcolors=black}
        \fancypagestyle{plain}{%
        \fancyhead{}        % clear all header fields
        \fancyfoot{}        % clear all header fields
        \fancyfoot[C]{\thepage}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}}

        \romantableofcontents
    }

    \chapter*{Informazioni e Contatti}      % \chapter* makes this a "fake" chapter
    \markboth{Informazioni e Contatti}{}    % Manually sets \leftmark (current chapter name)
    \addcontentsline{toc}{chapter}{Informazioni e Contatti}     % Manually adds chapter to ToC
    
    \subsubsection{Prerequisiti consigliati:}
    \begin{itemize}
        \item Algebra
        \item TODO
    \end{itemize}

    \quad

    \subsubsection{Segnalazione errori ed eventuali migliorie:}
    
    Per segnalare eventuali errori e/o migliorie possibili, si prega di utilizzare il \textbf{sistema di Issues fornito da GitHub} all'interno della pagina della repository stessa contenente questi ed altri appunti (link fornito al di sotto), utilizzando uno dei template già forniti compilando direttamente i campi richiesti.

    Gli appunti sono in continuo aggiornamento, pertanto, previa segnalazione, si prega di controllare se l'errore sia ancora presente nella versione più recente.

    \quad

    \subsubsection{Licenza di distribuzione:}
    
    These documents are distributed under the \textbf{\href{https://www.gnu.org/licenses/fdl-1.3.txt}{GNU Free Documentation License}}, a form of copyleft intended to be used on manuals, textbooks or other types of document in order to assure everyone the effective freedom to copy and redistribute it, with or without modifications, either commercially or non-commercially.
    
    \quad

    \subsubsection{Contatti dell'autore e ulteriori link:}
    \begin{itemize}
        % \item TODO: DECOMMENTARE QUESTA SEZIONE

        % Simone
        % 
        % \item Altri appunti: \textbf{\href{https://github.com/Exyss/university-notes}{https://github.com/Exyss/university-notes}}
        % \item Github: \textbf{\href{https://github.com/Exyss}{https://github.com/Exyss}}
        % \item Email: \textbf{\href{mailto:bianco.simone@outlook.it}{bianco.simone@outlook.it}}
        % \item LinkedIn: \textbf{\href{https://www.linkedin.com/in/simone-bianco}{Simone Bianco}}

        % Alessio
        % 
        \item Github: \textbf{\href{https://github.com/ph04}{https://github.com/ph04}}
        \item Email: \textbf{\href{mailto:alessio.bandiera02@gmail.com}{alessio.bandiera02@gmail.com}}
        \item LinkedIn: \textbf{\href{https://www.linkedin.com/in/alessio-bandiera-a53767223/}{Alessio Bandiera}}
    \end{itemize}

    %%%%%%%%%%%%%%%%%%%%%

    \chapter{Induzione}
    
    \section{Algebre induttive}

    \subsection{Assiomi di Peano}

    \begin{frameddefn}[label={peano}]{Assiomi di Peano}
        Gli \tbf{assiomi di Peano} sono 5 assiomi che definiscono l'insieme $\N$, e sono i seguenti:

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $0 \in \N$
            \item $\exists \func{\mathrm{succ}}{\N}{\N}$, o equivalentemente, $\forall x \in \N \quad \mathrm{succ}(x) \in \N$
            \item $\forall x, y \in \N \quad x \neq y \implies \mathrm{succ}(x) \neq \mathrm{succ}(y)$
            \item $\nexists x \in \N \mid \mathrm{succ}(x) = 0$
            \item $\forall S \subseteq \N \quad (0 \in S \land (\forall x \in S \quad \mathrm{succ}(x) \in S)) \implies S = \N$
        \end{enumerate}
    \end{frameddefn}

    \begin{example}[$\N$ di von Neumann]
        Una rappresentazione dell'insieme dei numeri naturali $\N$ alternativa alla canonica $$\N := \{0, 1, 2, \ldots \}$$ è stata fornita da John von Neumann. Indicando tale rappresentazione con $\aleph$, si ha che, per Neumann $$\begin{array}{c} 0_\aleph := \varnothing  = \{\} \\ 1_\aleph := \{ 0_\aleph \} = \{ \{ \}\} \\ 2_\aleph := \{0_\aleph, 1_\aleph\} = \{\{\}, \{\{ \}\}\} \\ \vdots \end{array}$$ e la funzione $\mathrm{succ}_\aleph$ è definita come segue $$\funcmap{\mathrm{succ}_\aleph}{\aleph}{\aleph}{x_\aleph}{x_\aleph \cup \{x_\aleph\} = \{\mu_\aleph \in \aleph \mid |\mu_\aleph| \le |x_\aleph|\}}$$ ed in particolare $\forall x_\aleph \in \aleph \quad |x_\aleph| + 1 = |\mathrm{succ}_\aleph(x_\aleph)|$.

        È possibile verificare che tale rappresentazione di $\N$ soddisfa gli assiomi di Peano, in quanto

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $0_\aleph := \varnothing \in \aleph$;
            \item $\exists \func{\mathrm{succ}_\aleph}{\aleph}{\aleph}$, definita precedentemente;
            \item $\forall x_\aleph, y_\aleph \in \aleph \quad x_\aleph \neq y_\aleph \implies |x_\aleph| \neq |y_\aleph| \implies  |\mathrm{succ}_\aleph(x_\aleph)| \neq |\mathrm{succ}_\aleph(y_\aleph)| \implies \mathrm{succ}_\aleph(x_\aleph) \neq \mathrm{succ}_\aleph(y_\aleph)$;
            \item per assurdo, sia $x_\aleph \in \aleph$ tale che $\mathrm{succ}_\aleph(x_\aleph) = 0_\aleph := \varnothing$; per definizione $\mathrm{succ}_\aleph(x_\aleph) := \{\mu_\aleph \in \aleph \mid |\mu_\aleph| \le |x_\aleph|\}$, ma non esiste $\mu_\aleph \in \aleph$ con cardinalità minore o uguale 0, e dunque $\nexists x_\aleph \in \aleph \mid \mathrm{succ}_\aleph(x_\aleph) = 0_\aleph$;
            \item per assurdo, sia $S \subseteq \aleph$ tale che $0_\aleph \in S$ e $\forall x_S \in S \quad \mathrm{succ}_\aleph(x_S) \in S$ ma $S \neq \aleph \iff \aleph - S \neq \varnothing \implies \exists \zeta_\aleph \in \aleph - S$, ed in particolare $\zeta_\aleph \neq 0_\aleph$; $\aleph$ è chiuso su $\mathrm{succ}_\aleph$ per il secondo assioma di Peano, e dunque $\zeta_\aleph \neq 0_\aleph \implies \exists \zeta'_\aleph \in \aleph \mid \mathrm{succ}_\aleph(\zeta'_\aleph) = \zeta_\aleph$, e sicuramente $\zeta'_\aleph \notin S$, poiché altrimenti $\zeta_\aleph \in S$ anch'esso in quanto $S$ è chiuso rispetto a $\mathrm{succ}_\aleph$; allora, ripetendo il ragionamento analogo per l'intera catena di predecessori, $S$ risulterebbe essere vuoto, ma ciò è impossibile poiché $0_\aleph \in S$ in ipotesi $\lightning$.
        \end{enumerate}
    \end{example}

    \begin{framedprinc}[label={induction}]{Principio di Induzione}
        Sia $P$ una proprietà che vale per $n = 0$, e dunque $P(0)$ è vera; inoltre,  per ogni $n \in \N$ si ha che $P(n) \implies P(n + 1)$; allora, $P(n)$ è vera per ogni $n \in \N$.

        In simboli, utilizzando la notazione della logica formale, si ha che $$\dfrac{P(0) \quad \dfrac{\forall n \in \N \quad P(n)}{P(n + 1)}}{\forall n \in \N \quad P(n)}$$
    \end{framedprinc}

    \begin{framedobs}{Quinto assioma di Peano}
        Si noti che il quinto degli assiomi di Peano (\cref{peano}) equivale al principio di induzione (\cref{induction}). Infatti, il quinto assioma afferma che qualsiasi sottoinsieme $S$ di $\N$ avente lo 0, e caratterizzato dalla chiusura sulla funzione di successore $\mathrm{succ}$, coincide con $\N$ stesso.
    \end{framedobs}

    \subsection{Algebre induttive}

    \begin{frameddefn}{Segnatura di una funzione}
        Data una funzione $f$, si definisce $$\func{f}{A}{B}$$ come \tbf{segnatura della funzione} $f$, dove $A$ è detto \tbf{dominio}, denotato con $\dom{(f)}$ e $B$ \tbf{codominio} di $f$.
    \end{frameddefn}

    \begin{frameddefn}{Algebra}
        Una \tbf{struttura algebrica}, o più semplicemente \tbf{algebra}, consiste di un insieme \tit{non vuoto}, talvolta chiamato \tbf{insieme sostegno} (\tit{carrier set} o \tit{domain}), fornito di una o più operazioni su tale insieme, quest'ultime caratterizzate da un numero finito di assiomi da soddisfare.

        Se $A$ è il carrier set, e $\gamma_1, \ldots \gamma_n$ sono delle operazioni definite su $A$, allora con $$(A, \gamma_1, \ldots, \gamma_n)$$ si indica l'algebra costituita da tali componenti, e questo simbolismo prende il nome di \tbf{segnatura dell'algebra}.
    \end{frameddefn}

    \begin{example}[Strutture algebriche con singola operazione]
        Esempi di strutture algebriche con un'operazione binaria sono i seguenti:

        \begin{itemize}
            \item semigruppi
            \item monoidi
            \item gruppi
            \item gruppi abeliani
        \end{itemize}
    \end{example}

    \begin{example}[Strutture algebriche con due operazioni]
        Esempi di strutture algebriche con due operazioni binarie sono i seguenti:

        \begin{itemize}
            \item semianelli
            \item anelli
            \item campi
        \end{itemize}
    \end{example}

    \begin{frameddefn}{Insieme unità}
        Con \tbf{insieme unità} si intende un qualsiasi insieme tale che $\abs{\1} = 1$, e verrà indicato attraverso il simbolo $\1$.
    \end{frameddefn}

    \begin{frameddefn}{Funzione nullaria}
        Dato un insieme A, con \tbf{funzione nullaria} si intende una qualsiasi funzione con segnatura $$\func{f}{\1}{A}$$
    \end{frameddefn}

    \begin{framedobs}[label={inj null}]{Iniettività della funzione nullaria}
        Si noti che ogni funzione nullaria è iniettiva, poiché il dominio è costituito da un solo elemento.
    \end{framedobs}

    \begin{frameddefn}[label={inductive algebra}]{Algebra induttiva}
        Sia $A$ un insieme, e siano $\gamma_1, \ldots, \gamma_n$ funzioni definite su $A$ di arbitraria arietà; allora, $(A, \gamma_1, \ldots, \gamma_n)$ è definita \tbf{algebra induttiva} se si verificano le seguenti:

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $\gamma_1, \ldots, \gamma_n$ sono iniettive
            \item $\forall i, j \in [1, n] \mid i \neq j \quad \im(\gamma_i) \cap \im(\gamma_j) = \varnothing$, ovvero, le immagini dei costruttori sono a due a due disgiunte
            \item $\forall S \subseteq A \quad (\forall i \in [1, n], a_1, \ldots a_k \in S, k \in \N  \quad \gamma_i(a_1, \ldots, a_k) \in S) \implies S = A$, o equivalentemente, in $A$ non devono essere contenute algebre induttive.
        \end{enumerate}

        Le funzioni $\gamma_1, \ldots, \gamma_n$ prendono il nome di \tbf{costruttori dell'algebra}.
    \end{frameddefn}

    \begin{framedobs}[label={third inductive algebra}]{Terzo assioma delle algebre induttive}
        Si noti che nel terzo assioma della \cref{inductive algebra} anche $S = \varnothing$ è un valido sottoinsieme di $A$, ma poiché non esistono $a_1, \ldots, a_k \in \varnothing$, in esso ogni qualificazione è vera a vuoto. Di conseguenza, nel momento in cui si ammette $S = \varnothing$ nel terzo assioma, l'algebra risulta essere non induttiva necessariamente (a meno dell'algebra vuota).
        
        Di conseguenza, questo terzo assioma forza la necessità della presenza di un costruttore nullario all'interno di ogni algebra induttiva, in modo da non poter ammettere $S = \varnothing$, poiché l'algebra deve essere chiusa su ognuno dei suoi costruttori.
    \end{framedobs}

    \begin{example}[Numeri naturali]
        $(\N, +)$ non è un algebra induttiva, poiché esistono $x_1, x_2, x_3, x_4 \in \N$ con $x_1 \neq x_3$ e $x_2 \neq x_4$ tali che $x_1 + x_2 = x_3 + x_4$; ad esempio, 2 + 3 = 5 = 1 + 4, e 2 $\neq$ 1, 3 $\neq$ 4.
    \end{example}

    \begin{example}[Algebra di Boole]
        Dato l'insieme $B = \{ \mathrm{true}, \mathrm{false}\}$, e la funzione $\lnot$ definita come segue $$\funcmap{\lnot}{B}{B}{x}{\left \{ \begin{array}{ll} \mathrm{false} & x = \mathrm{true} \\ \mathrm{true} & x = \mathrm{false} \end{array} \right.}$$ è possibile dimostrare che l'algebra $(B, \lnot)$ non è induttiva; infatti, nonostante $\lnot$ sia iniettiva, e la seconda proprietà della \cref{inductive algebra} sia vera a vuoto, $(B, \lnot)$ non presenta costruttore nullario, e dunque non può costituire un'algebra induttiva (si noti l'\cref{third inductive algebra}).
    \end{example}

    \begin{example}[Algebre induttive]
        Sia $\mathrm{zero}$ la funzione definita come segue $$\funcmap{\mathrm{zero}}{\1}{\N}{x}{0}$$ e si prenda in esame l'algebra $(\N, \mathrm{succ}, \mathrm{zero})$; allora si ha che

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $\mathrm{succ}$ e $\mathrm{zero}$ sono iniettive, poiché
                \begin{itemize}
                    \item $\mathrm{succ}$ è iniettiva per il terzo assioma di Peano (\cref{peano})
                    \item $\mathrm{zero}$ è iniettiva per l'\cref{inj null}
                \end{itemize}
            \item $\im(\mathrm{succ}) \cap \im(\mathrm{zero}) = \left(\N - \{0\}\right) \cap \{0\} = \varnothing$
            \item TODO
        \end{enumerate}
    \end{example}

    \begin{frameddefn}{Omomorfismo}
        Un \tbf{omomorfismo} è una funzione, tra due algebre dello stesso tipo, tale da preservarne le strutture.

        Formalmente, siano $(A, \mu_1, \ldots, \mu_n)$ e $(B, \delta_1, \ldots, \delta_n)$ due algebre tali che ogni funzione $\mu_i$ abbia la stessa arietà e lo stesso numero di parametri esterni (denotati con $k$) di $\delta_i$, pari rispettivamente ad $\eta_i$ ed a $\nu_i$, per qualche $i \in [1, n]$; allora, una funzione $\func{f}{A}{B}$ è detta essere un \tbf{omomorfismo} tra le due algebre, se e solo se $$\begin{array}{c} \forall a_1, \ldots, a_{\eta_1} \quad f(\mu_1(a_1, \ldots, a_{\eta_n}), k_1, \ldots, k_{\nu_1}) = \delta_1(f(a_1), \ldots, f(a_{\eta_1}), k_1, \ldots, k_{\nu_1}) \\ \vdots \\ \forall a_1, \ldots, a_{\eta_n} \quad f(\mu_n(a_1, \ldots, a_{\eta_n}), k_1, \ldots, k_{\nu_n}) = \delta_n(f(a_1), \ldots, f(a_{\eta_n}), k_1, \ldots, k_{\nu_n}) \end{array}$$
    \end{frameddefn}

    \begin{example}[Omomorfismi]
        \label{homo}
        Si considerino i gruppi $(\R, +)$ e $(\R_{> 0}, \cdot)$, e sia $f$ definita come segue: $$\funcmap{f}{\R}{\R_{> 0}}{x}{e^x}$$ allora, si ha che $$\forall x, y \in \R \quad f(x) \cdot f(y) = e^x \cdot e^y = e^{x + y} = f(x + y)$$ dunque $f$ è un omomorfismo di gruppi.
    \end{example}

    \begin{frameddefn}{Isomorfismo}
        Un \tbf{isomorfismo} è un omomorfismo biettivo.
    \end{frameddefn}

    \begin{example}[Isomorfismi]
        Si consideri l'omomorfismo dell'\cref{homo}; si noti che $$\forall x, y \in \R \mid x \neq \R \quad e^x \neq e^y \implies f(x) \neq f(y)$$ e dunque $f$ è iniettiva; inoltre $$\forall y \in \R_{> 0} \quad \exists x \in \R \mid f(x) = e^x = y \iff y = \ln(x)$$ e dunque $f$ è suriettiva. Allora, $f$ è biettiva, e poiché è un omomorfismo, risulta essere un isomorfismo.
    \end{example}

    \section{Strutture dati induttive}

    \subsection{Liste}

    \begin{frameddefn}{Liste}
        Una \tbf{lista} è una collezione ordinata di elementi, e l'insieme delle liste di lunghezza finita viene denotato con $\ttt{List<T>}$, dove $\ttt T$ è il tipo degli elementi che le liste contengono, ed il simobolo $\ttt T$ verrà identificato con l'insieme di tutti gli oggetti aventi tipo $\ttt T$.

        Dati $a_1, \ldots, a_n \in \ttt T$, una lista $l \in \ttt{List<T>}$ contenente tali elementi può essere rappresentata come segue: $$\ttt [ a_1, \ldots, a_n \ttt ]$$
    \end{frameddefn}

    \begin{frameddefn}{Algebra delle liste finite}
        L'\tbf{algebra delle liste finite} è definita come segue: $$(\ttt{List<T>}, \mathrm{empty}, \mathrm{cons})$$ dove i costruttori sono i seguenti: $$\centeredsoe{\funcmap{\mathrm{empty}}{\1}{\ttt{List<T>}}{x}{\ttt{[]}} \\ \funcmap{\mathrm{cons}}{\ttt{List<T>} \times \ttt{T}}{\ttt{List<T>}}{(\ttt [ a_1, \ldots, a_n \ttt ], x)}{\ttt [ a_1, \ldots, a_n , x \ttt ]}}$$
    \end{frameddefn}

    \begin{framedprop}[label={alf induttiva}]{Liste finite induttive}
        L'algebra delle liste finite è induttiva.
    \end{framedprop}

    \begin{proof}
        Si noti che:

        \begin{itemize}
            \item $\mathrm{empty}$ ha dominio in $\1$, e poiché questo contiene un solo elemento, $\mathrm{empty}$ è necessariamente iniettiva;
            \item $\forall l, l' \in \ttt{List<T>}, x, x' \in \ttt{T} \quad \mathrm{cons}(l, x) = \mathrm{cons}(l', x') \implies \soe{l}{l = l' \\ x = x'}$ altrimenti $l$ ed $l'$ avrebbero avuto lunghezze diverse, oppure avrebbero contenuto diversi elementi;
            \item $\im{(\mathrm{empty})} \cap \im{(\mathrm{cons})} = \varnothing$, poiché solo $\mathrm{empty}$ può restituire $\ttt [ \ttt ]$, in quanto $\mathrm{cons}$ restituisce sempre una lista contenente almeno l'elemento fornito in input;
            \item sia $S \subseteq \ttt{List<T>}$ tale da essere chiuso rispetto a $\mathrm{cons}$, e contenente la lista vuota; per assurdo, sia $\ttt{List<T>} - S \neq \varnothing \implies \exists l \in \ttt{List<T>} - S$, ma $\ttt{List<T>}$ è chiuso rispetto a $\mathrm{cons}$, ed in particolare $\exists x \in \ttt{T}, l' \in \ttt{List<T>} \mid \mathrm{cons}(l', x) = l$, ma poichè $l \notin S$, allora necessariamente $l' \notin S$, poiché $S$ è chiuso rispetto a $\mathrm{cons}$, e quindi $l' \in S \implies l \in S$, ma $l$ è stato scelto in $\ttt{List<T>} - S$; ripetendo tale ragionamento induttivamente, si ottiene che $S$ è vuoto, ma questo è impossibile poiché $\ttt{[]} \in \ttt{List<T>}$ in ipotesi $\lightning$.
        \end{itemize}

        Dunque, l'algebra delle liste finite risulta essere induttiva.
    \end{proof}

    \begin{framedobs}[label={infinite lists}]{Algebra delle liste infinite}
        Se all'algebra delle liste finite venissero aggiunte anche le liste infinite, l'algebra risultante non sarebbe induttiva, in quanto conterrebbe l'algebra delle liste finite, la quale è induttiva per la \cref{alf induttiva}, e verrebbe dunque contraddetto il terzo assioma della \cref{inductive algebra}.
    \end{framedobs}

    \begin{framedobs}{Concatenazione di liste finite}
        È possibile estendere l'algebra delle liste finite per supportare l'operazione di concatenazione tra liste, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{concat}}{\ttt{List<T>} \times \ttt{List<T>}}{\ttt{List<T>}}{(l, l')}{\soe{ll}{l' & l = \ttt{[]} \\ \mathrm{cons}(x, \mathrm{concat}(t, l')) & \exists x \in \ttt T, t \in \ttt{List<T>} \mid l = \mathrm{cons}(t, x)}}$}
    \end{framedobs}

    \subsection{Alberi binari}

    \begin{frameddefn}{Albero binario}
        Un \tbf{albero binario} è una struttura dati che è possibile rappresentare graficamente come segue:

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[
                    level distance=1cm,
                    level 1/.style={sibling distance=2cm},
                    level 2/.style={sibling distance=1cm}
                ]
                \node {$\circ$}
                    child {node {$\circ$}
                    child {node {$\circ$}}
                    child {node {$\circ$}}
                }
                    child {node {$\circ$}
                };
            \end{tikzpicture}
        \end{figure}

        Il primo nodo, poiché non è figlio di nessuno, è detto \tbf{radice}, e poiché l'albero è \tit{binario}, ogni nodo ha 0 --- nel qual caso è definito \tbf{foglia} --- oppure 2 figli. L'insieme degli alberi binari viene denotato con \ttt{B-tree}.
    \end{frameddefn}

    \begin{frameddefn}{Algebra degli alberi binari finiti}
        L'\tbf{algebra degli alberi binari finiti} è definita come segue: $$(\ttt{B-tree}, \mathrm{leaf}, \mathrm{branch})$$ dove i costruttori sono i seguenti:

        $$\funcmap{\mathrm{leaf}}{\1}{\ttt{B-tree}}{x}{\circ}$$

        \begin{center}
            \begin{tabular}{c c}
                \begin{tabular}{c}$\funcmap{\mathrm{branch}}{\ttt{B-tree} \times \ttt{B-tree}}{\ttt{B-tree}}{(b, b')}{}$\end{tabular}
                &
                \begin{tabular}{c}
                    \begin{tikzpicture}[
                            level distance=1cm,
                            level 1/.style={sibling distance=1cm},
                        ]
                        \node {$\circ$}
                            child {node {$b$}
                        }
                            child {node {$b'$}
                        };
                    \end{tikzpicture}
                \end{tabular}
            \end{tabular}
        \end{center}
    \end{frameddefn}

    \begin{framedprop}{Alberi binari finiti induttivi}
        L'algebra degli alberi binari finiti è induttiva.
    \end{framedprop}

    \begin{proof}
        Omessa.
    \end{proof}

    \begin{framedobs}{Algebra degli alberi binari infiniti}
        Analogamente all'\cref{infinite lists}, l'algebra degli alberi binari finiti ed infiniti non è induttiva.
    \end{framedobs}

    \begin{framedobs}{Nodi di un albero binario finito}
        È possibile estendere l'algebra degli alberi binari finiti per supportare l'operazione per contare i nodi di un albero, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{nodes}}{\ttt{B-tree}}{\N}{b}{\soe{ll}{1 & b = \circ \\ 1 + \mathrm{nodes}(t) + \mathrm{nodes}(t')  & \exists t, t' \in \ttt{B-tree} \mid b = \mathrm{branch}(t, t')}}$}
    \end{framedobs}

    \begin{framedobs}{Foglie di un albero binario finito}
        È possibile estendere l'algebra degli alberi binari finiti per supportare l'operazione per contare le foglie di un albero, come segue: $$\funcmap{\mathrm{leaves}}{\ttt{B-tree}}{\N}{b}{\soe{ll}{1 & b = \circ \\ \mathrm{leaves}(t) + \mathrm{leaves}(t') & \exists t, t' \in \ttt{B-tree} \mid b = \mathrm{branch}(t, t')}}$$
    \end{framedobs}

    \begin{framedthm}{Relazione tra foglie e nodi}
        Ogni albero binario finito, avente $n$ foglie, ha $2n - 1$ nodi.
    \end{framedthm}

    \proofind{
        La seguente dimostrazione procede per \tit{induzione strutturale}, dunque effettuando l'induzione sulla morfologia della struttura dati, e non sul numero $n$ di foglie.
    }{
        Il caso base è costituito dunque da $\circ$, l'albero ottenuto attraverso il costruttore nullario $\mathrm{leaf}$, ed infatti si ha che $$\mathrm{leaves}(\circ) = 1 \implies 2 \cdot 1 - 1 = 1$$ e $\circ$ ha esattamente 1 nodo.
    }{
        Un albero binario finito, avente $n$ foglie, ha $2n - 1$ nodi.
    }{
        Sia $b \in \ttt{B-tree}$ tale che esistano $t, t' \in \ttt{B-tree}$ tali che $\mathrm{branch}(t, t') = b$, e siano $$\soe{l}{\mathrm{leaves}(t) = n \\ \mathrm{leaves}(t') = n'}$$ Si noti che, per ipotesi induttiva, si ha che $$\soe{l}{\mathrm{nodes}(t) = 2n - 1 \\ \mathrm{nodes}(t') = 2n' - 1}$$ ed inoltre, poiché $b = \mathrm{branch}(t, t')$, $b$ ha la forma seguente

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[
                    level distance=1cm,
                    level 1/.style={sibling distance=1cm},
                ]
                \node {$\circ$}
                    child {node {$t$}
                }
                    child {node {$t'$}
                };
            \end{tikzpicture}

        \end{figure}
        dunque, per definizione di $\mathrm{leaves}$ si ha che $$\mathrm{leaves}(b) = \mathrm{leaves}(t) + \mathrm{leaves}(t') = n + n'$$ e, dalla morfologia di $b$, segue che $$\mathrm{nodes}(b) = \mathrm{nodes}(t) + \mathrm{notes}(t') + 1 = 2n -1 + 2n'-1 + 1 = 2(n + n') - 1$$ ed è quindi verificata la tesi, poiché $$\mathrm{leaves}(b) = n + n' \implies \mathrm{nodes}(b) = 2(n + n') - 1$$
    }
    
    \chapter{Paradigma funzionale}

    \section{Grammatiche}
    
    \subsection{Definizioni}

    \begin{frameddefn}{Grammatica}
        Una \tbf{grammatica} è un insieme di regole che definiscono come manipolare un insieme di stringhe, agendo su elementi sintattici detti \tbf{termini}.
    \end{frameddefn}

    \begin{frameddefn}{Forma di Backus-Naur (BNF)}
        La \tbf{forma di Backus-Naur} (\tit{Backus-Naur Form}) è una notazione utilizzata per descrivere la sintassi di grammatiche, ed è definita come segue: $$\ttt{<symbol>}, \ldots, \ttt{<symbol>} ::= \ttt{\_expression\_} \ | \ \ldots \ | \ \ttt{\_expression\_}$$ dove
        \begin{itemize}
            \item $\ttt{<symbol>}$ è una \tit{metavariabile non terminale}, ovvero, può essere sostituito con regole definite dalla grammatica; si noti che le regole possono essere utilizzate \und{ricorsivamente};
            \item il simbolo $::=$ indica che ciò che è posto alla sua sinistra deve essere sostituito con ciò che è alla sua destra;
            \item $\ttt{\_expression\_}$ è un espressione che verrà usata per rimpiazzare le metavariabili non terminali, attraverso le regole definite dalla grammatica; le \tit{metavarabili} che compongono le espressioni possono essere \tbf{costanti}, \tbf{variabili}, \tbf{termini} o \tbf{espressioni} contenenti combinazioni delle precedenti, presentando eventualmente anche operazioni sintattiche specifiche.
        \end{itemize}
    \end{frameddefn}

    \begin{example}[Grammatica $Exp$]
        \label{exp}
        Sia $Exp$ la seguente grammatica: $$M, N ::= \ttt 0 \ | \ \ttt 1 \ | \ldots \ | \ x \ | \ M \ \ttt + \ N \ | \ M \ \ttt * \ N$$ essa definisce le regole per utilizzare i numeri in $\N$, ammettendo inoltre le operazioni \und{sintattiche} di $\ttt +$ e $\ttt *$.

        All'interno di questa grammatica dunque, le metavariabili utilizzate sono le seguenti:
        \begin{itemize}
            \item \tit{costanti}: $\ttt 0, \ttt 1,  \ldots$
            \item \tit{variabili}: $x$
            \item \tit{termini}: $M$ ed $N$
            \item \tit{espressioni}: $M \ \ttt + \ N$ e $M \ \ttt * \ N$ (tecnicamente anche le precedenti sono espressioni, ma queste in particolare sfruttano operazioni sintattiche precise)
        \end{itemize}
    \end{example}

    \begin{frameddefn}{Variabili}
        Data una grammatica di $G$, con $\mathrm{Var}$ si indica l'\tbf{insieme delle variabili} di $G$.
    \end{frameddefn}

    \begin{frameddefn}{Valori}
        Data una grammatica, con $\mathrm{Val}$ si indica l'\tbf{insieme dei valori} che ogni termine della grammatica può assumere.
    \end{frameddefn}

    \begin{example}[Variabili e valori di $Exp$]
        Si prenda in considerazione la grammatica $Exp$ dell'\cref{exp2}; in essa, si ha che $$\centeredsoe{\mathrm{Var} = \{ x \} \\ \mathrm{Val} = \{ \ttt 0, \ttt 1, \ldots \}}$$
    \end{example}

    \begin{frameddefn}{Linguaggio di una grammatica}
        Sia $G$ una grammatica; allora, il suo \tbf{linguaggio} è l'insieme delle stringhe che è possibile costruire attraverso le regole dettate da $G$.
    \end{frameddefn}

    \begin{example}[Linguaggio di $Exp$]
        Si prenda in considerazione $Exp$, la grammatica definita all'interno dell'\cref{exp}; in essa, prendendo ad esempio le stringhe $\ttt{"4"}$ e $\ttt{"23"}$, si può ottenere la stringa $$\ttt{+}(\ttt{"4"}, \ttt{"23"}) = \ttt{"4 + 23"}$$ dove la \tit{polish notation} --- alla sinistra dell'uguale --- e la forma sintattica canonica --- alla sua destra --- verranno utilizzate intercambiabilmente, poiché puro \tit{syntactic sugar}.
    \end{example}

    \begin{framedobs}[label={eval}]{Valutazione di $Exp$}
        Si prenda in considerazione la grammatica $Exp$ dell'\cref{exp}; su di essa, è possibile definire ricorsivamente una funzione $\mathrm{eval}$, in grado di valutare le stringhe che tale grammatica può produrre, come segue: $$\centeredsoe{\mathrm{eval}(\ttt 0) = \ttt 0 \\ \mathrm{eval}(\ttt 1) = \ttt 1 \\ \vdots \\ \mathrm{eval}(M \ \ttt + \ N) = \mathrm{eval}(M) \ \ttt + \ \mathrm{eval}(N) \\ \mathrm{eval}(M \ \ttt * \ N) = \mathrm{eval}(M) \ \ttt * \ \mathrm{eval}(N)}$$
    \end{framedobs}

    \begin{framedobs}[label={ambiguity}]{Ambiguità di $Exp$}
        Si prenda in considerazione la grammatica $Exp$ dell'\cref{exp}; si noti che tale grammatica è ambigua, poichè ad esempio $$\ttt{+}(\ttt{"5"}, \ttt{*}(\ttt{"6"}, \ttt{"7"})) = \ttt{"5 + 6 * 7"} = \ttt{*}(\ttt{+}(\ttt{"5"}, \ttt{"6"}), \ttt{"7"})$$ e da ciò segue anche che $\im{(\ttt+)} \cap \im{(\ttt *)} \neq \varnothing$.
    \end{framedobs}

    \begin{framedobs}{Disambiguazione di $Exp$}
        Si noti che l'ambiguità trattata nell'\cref{ambiguity} non permetterebbe di poter definire la funzione $\mathrm{eval}$, descritta nell'\cref{eval}. Dunque, per risolvere tale ambiguità, a meno di parentesi (che \tit{non} sono definite all'interno della grammatica) o dell'esplicitazione della composizione di funzioni utilizzata, verrà sottointesa la normale precedenza degli operatori aritmetica durante la valutazione delle stringhe.
    \end{framedobs}

    \section{Assegnazioni}

    \subsection{Definizioni}

    \begin{frameddefn}[label={let}]{Clausola $let$}
        Sia $G$ una grammatica; allora, è possibile definire su $G$ una funzione \tbf{$let$}, come segue: $$\func{let}{\mathrm{Var} \times G \times G}{G}$$ e verrà utilizzata attraverso la sintassi $$\letin{\ttt{*variable*}}{\ttt{\_expression\_}_1}{\ttt{\_expression\_}_2}$$ ed alla variabile $\ttt{*variable*}$ verrà assegnata l'espressione $\ttt{\_expression\_}_1$ \tit{durante la valutazione} di $\ttt{\_expression\_}_2$; la variabile $\ttt{*variable*}$, all'interno di $\ttt{\_expression\_}_2$, prende il nome di \tbf{variabile locale}.

        Una variabile alla quale non è stata assegnata nessuna espressione prende il nome di \tbf{variable libera} (\tit{unbound variable} in inglese); una variabile non libera è detta \tbf{variabile legata} (\tit{bound variable}).
    \end{frameddefn}
    
    \begin{example}[Estensione di $Exp$]
        \label{exp2}
        Sia $Exp$ la seguente estensione della grammatica presente all'interno dell'\cref{exp}: $$M, N ::= k \ | \ x \ | \ M \ \ttt + \ N \ | \ M \ \ttt * \ N \ | \ \letin{x}{M}{N}$$

        In essa, sono presenti:

        \begin{itemize}
            \item \tit{costanti}: indicate con $k$, che sta ad indicare che in $Exp$ è ammessa qualsiasi costante; di fatto, è possibile pensare a $k$ come una funzione definita come segue: $$\funcmap{k}{\N}{Exp}{x}{\ttt{"x"}}$$
            \item \tit{variabili}: $x$
            \item \tit{termini}: $M$ ed $N$
            \item \tit{espressioni}: $M \ \ttt + \ N$, $M \ \ttt * \ N$ e $\letin{x}{M}{N}$
        \end{itemize}
    \end{example}

    \begin{example}[Clausole $let$]
        Sia $Exp$ la grammatica dell'\cref{exp2}; un esempio di espressione su $Exp$, che utilizza la clausola $let$ della \cref{let}, è la seguente: $$\letin{x}{3}{(x + 1)}$$ e nel momento in cui viene valutata tale espressione, si ha che $$x = 3 \implies x + 1 = 3 + 1 = 4$$ e dunque il valore dell'espressione è 4.
    \end{example}

    \begin{example}[Variabili libere]
        Sia $Exp$ la grammatica dell'\cref{exp2}, ed ammettendo la variabile $y$ in essa, si consideri la seguente espressione: $$\letin{x}{3}{(x + y)}$$ in essa, la variabile $x$ è posta pari a 3, ma ad $y$ non è stato assegnato alcun valore, e dunque risulta essere una variabile libera.
    \end{example}

    \begin{framedobs}{Ambiguità di $let$}
        Sia $Exp$ la grammatica dell'\cref{exp2}, e si consideri la sua seguente espressione $$\letin{x}{M}{x + y}$$ per qualche espressione $M \in Exp$, e due variabili $x, y \mathrm{Var}$, ammettendo dunque $y$ tra le variabili di $Exp$; si noti che tale espressione è ambigua, poiché potrebbe equivalere a $$(\letin{x}{M}{x}) + y$$ oppure a $$\letin{x}{M}{(x + y)}$$ Per convenzione, all'interno di questi appunti, in assenza di parentesi che descrivano la precedenza degli operatori, si assume la precedenza della seconda espressione mostrata.
    \end{framedobs}

    \begin{framedobs}{Variabili libere di un'espressione}
        Sia $Exp$ la grammatica dell'\cref{exp2}; su di essa, è possibile definire, ricorsivamente, una funzione in grado di restituire le variabili unbound di una data espressione, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{free}}{Exp}{\powerset{\left(\mathrm{Var}\right)}}{e}{\soe{ll}{
            \varnothing & \exists \eta \in \N \mid e = k(\eta) \\ 
            \{x\} & \exists x \in \mathrm{Var} \mid e = x \\ 
            \mathrm{free}(M) \cup \mathrm{free}(N) & \exists M, N \in Exp \mid e = M \ \ttt + \ N \lor e = M \ \ttt * \ N \\
            \mathrm{free}(M) \cup (\mathrm{free}(N) - \{x\}) & \exists x \in \mathrm{Var}, M, N \in Exp \mid e = (\letin{x}{M}{N})
        }}$}
    \end{framedobs}

    \subsection{Ambienti}
    
    \begin{frameddefn}{Ambiente di una grammatica}
        Data una grammatica tale che $\mathrm{Val}$ sia un insieme finito, un \tbf{ambiente} della grammatica è una funzione della forma $$E: \mathrm{Var} \xrightarrow{fin} \mathrm{Val}$$ che associa dunque una variabile, ad un possibile valore che può assumere con espressioni della grammatica di riferimento (la notazione $fin$ indica che le funzioni sono \tit{parziali}, dunque non necessariamente definite su tuto il dominio). L'insieme di tutti gli ambienti della grammatica è denotato con $$\mathrm{Env} := \{f \mid f : \mathrm{Var} \xrightarrow{fin} \mathrm{Val} \}$$

        In simboli, gli ambienti verranno scritti come insiemi di coppie $(x, k)$ con $x \in \mathrm{Var}, k \in \mathrm{Val}$, che descriveranno la mappa definita dall'ambiente stesso. Si noti che $E(x)$ è indefinito per ogni $x \in \mathrm{Var} - \dom(E)$.
    \end{frameddefn}

    \begin{example}[Ambiente di $Exp$]
        Sia $Exp$ la grammatica dell'\cref{exp2}; allora, un possibile ambiente di $Exp$, denotato con $E \in \mathrm{Env}$, è il seguente: $$E := \{(z,3), (y, 9) \}$$ ed esso esprime la possibilità che in $Exp$ $z$ possa essere valutato pari a 3, mentre $y$ pari a 9.
    \end{example}

    \begin{frameddefn}{Concatenazione di ambienti}
        Siano $E_1$ ed $E_2$ due ambienti di una grammatica; si definisce la \tbf{concatenazione} di $E_1$ ed $E_2$ la seguente funzione $$E_1E_2: \mathrm{Env} \times \mathrm{Env} \to \mathrm{Env} : x \mapsto \soe{ll}{E_2 & x \in \dom{(E_2)} \lor x \in \dom{(E_1)} \cup \dom{(E_2)} \\ E_1(x) & x \in \dom{(E_1)}}$$ dunque, nella concatenazione $E_2$ sovrascrive le tuple che sono presenti anche in $E_1$.
    \end{frameddefn}

    \begin{example}[Concatenazione di ambienti]
        Sia $Exp$ la grammatica descritta all'interno del \cref{exp2}, e siano $$\centeredsoe{E_1 := \{(z, 3), (y, 9)\} \\ E_2 := \{(z, 4)\}}$$ due suoi ambienti; allora si ha che $$E_1E_2 := \{(z, 4), (y, 9)\}$$
    \end{example}

    \subsection{Semantica operazionale}

    \begin{frameddefn}{Semantica operazionale di una grammatica}
        Data una grammatica $G$, si definisce \tbf{semantica operazionale} della grammatica una relazione, indicata col simbolo $\leadsto$, definita come segue: $$\leadsto \ \subseteq \mathrm{Env} \times G \times \mathrm{Val}$$

        Un elemento $(E, M, v) \in \ \leadsto$ è detto \tbf{giudizio operazionale}, e viene scritto col seguente simbolismo: $$\opjud{E}{M}{v}$$ e si legge "valutando $M$, nell'ambiente $E$ si ottiene $v$".
    \end{frameddefn}

    \begin{example}[label={sem op exp}][Semantica operazionale di $Exp$]
        Sia $Exp$ la grammatica definita all'interno dell'\cref{exp2}, e sia $E$ un suo ambiente; allora, sono vere le seguenti asserzioni:
        
        $$[const] \ \opjud{E}{k}{k}$$
        $$\forall x \in \mathrm{Var} \quad \exists v \in \mathrm{Val} \mid E(x) = v \implies [var] \ \opjud{E}{x}{v}$$
        \centeredeq{0.9}{$\forall v', v'' \in \mathrm{Val}, M, N \in Exp \quad \exists v \in \mathrm{Val} \mid v = v' + v'' \implies [plus] \ \dfrac{\opjud{E}{M}{v'} \quad \opjud{E}{N}{v''}}{\opjud{E}{M \ \ttt + \ N}{v}}$}
        \centeredeq{0.9}{$\forall v', v'' \in \mathrm{Val}, M, N \in Exp \quad \exists v \in \mathrm{Val} \mid v = v' \cdot v'' \implies [times] \ \dfrac{\opjud{E}{M}{v'} \quad \opjud{E}{N}{v''}}{\opjud{E}{M \ \ttt * \ N}{v}}$}
        $$\forall v, v' \in \mathrm{Val}, x \in \mathrm{Var}, M, N \in Exp \quad [let] \ \dfrac{\opjud{E}{M}{v'} \quad \opjud{E\{(x, v')\}}{N}{v}}{\opjud{E}{\letin{x}{M}{N}}{v}}$$
    \end{example}

    \begin{frameddefn}{Equivalenza operazionale}
        Sia $G$ una grammatica, e siano $M$ ed $N$ due sue espressioni; queste sono dette \tbf{operazionalmente equivalenti}, se è vera la seguente proposizione: $$\forall E \in \mathrm{Env}, v \in \mathrm{Val} \quad \opjud{E}{M}{v} \iff \opjud{E}{N}{v}$$ e viene indicato con $M \sim N$.
    \end{frameddefn}

    \begin{frameddefn}{Albero di valutazione}
        Con \tbf{albero di valutazione} di un'espressione $e$, si definisce l'albero, composto da inferenze logiche, ottenuto dalla valutazione di $e$.
    \end{frameddefn}

    \begin{framedobs}{Ambiente iniziale}
        Per qualsiasi grammatica, meno di specifiche si assume che, all'interno di una valutazione, l'ambiente iniziale sia $\varnothing \subseteq \mathrm{Env}$.
    \end{framedobs}

    \begin{example}[Alberi di valutazione su $Exp$]
        Sia $Exp$ la grammatica definita all'interno dell'\cref{exp2}; allora, l'albero di valutazione dell'espressione $$\letin{x}{3}{x + 4}$$ è il seguente $$\dfrac{\opjud{\varnothing}{3}{3} \quad \dfrac{\opjud{\{(x, 3)\}}{x}{3} \quad \opjud{\{(x,3)\}}{4}{4}}{\opjud{\{(x, 3)\}}{x +4}{7}}}{\opjud{\varnothing}{\letin{x}{3}{x +4}}{7}}$$ ed è valutabile poiché $x \in \dom(\{(x,1)\}) = \{x\}$.
    \end{example}

    \section{Valutazioni}

    \subsection{Valutazione eager}

    \begin{frameddefn}{Valutazione eager}
        Data una grammatica, la valutazione \tbf{eager} (detta anche \tit{call-by-name}) valuta una data espressione della grammatica non appena questa viene legata ad una variabile.
    \end{frameddefn}

    \begin{example}[Valutazione eager su $Exp$]
        Sia $Exp$ la grammatica definita all'interno dell'\cref{exp2}, e si consideri la seguente espressione: $$\letin{x}{M}{x + x}$$ essa, valutata attraverso valutazione eager, produce il seguente albero di derivazione: $$\dfrac{\dfrac{\ldots}{\opjud{\varnothing}{M}{v'}} \quad \dfrac{\opjud{\{(x, v')\}}{x}{v'} \quad \opjud{\{(x, v')\}}{x}{v'}}{\opjud{\{(x, v')\}}{x+x}{v}}}{\opjud{\varnothing}{\letin{x}{M}{x + x}}{v}}$$ dove $v, v' \in \mathrm{Var} \mid v = v' + v'$. Si noti dunque che le espressioni $M$ e $x + x$ sono state valutate entrambe sullo stesso livello.
    \end{example}

    \begin{example}[Valutazione eager su $Exp$]
        \label{eager2}
        Sia $Exp$ la grammatica definita all'interno dell'\cref{exp2}, e si consideri la seguente espressione: $$\letin{x}{3}{(\letin{y}{x}{(\letin{x}{7}{y + x})})}$$ essa, valutata attraverso valutazione eager, produce il seguente albero di derivazione: \centeredeq{0.99}{$\dfrac{\opjud{\varnothing}{3}{3} \quad \dfrac{\opjud{\{(x, 3)\}}{x}{3} \quad \dfrac{\opjud{\{(x,3),(y,3)\}}{7}{7} \quad \dfrac{\opjud{\{(x,3),(y,3)\}\{(x,7)\}}{y}{3} \quad \opjud{\{(x,3),(y,3)\}\{(x,7)\}}{x}{7}}{\opjud{\{(x,3),(y,3)\}\{(x,7)\}}{y+x}{10}}}{\opjud{\{(x, 3),(y, 3)\}}{\letin{x}{7}{y + x}}{10}}}{\opjud{\{(x, 3)\}}{\letin{y}{x}{(\letin{x}{7}{y + x})}}{10}}}{\opjud{\varnothing}{\letin{x}{3}{(\letin{y}{x}{(\letin{x}{7}{y + x})})}}{10}}$}
    \end{example}

    \subsection{Valutazione lazy}
    
    \begin{frameddefn}{Valutazione lazy}
        Data una grammatica, la valutazione \tbf{lazy} (detta anche \tit{call-by-need}) valuta una data espressione $e$ della grammatica solo quando il suo valore viene richiesto da un'altra espressione, che dunque dipende dal valore di $e$.
    \end{frameddefn}

    \begin{framedobs}{$Exp$ lazy}
        Sia $Exp$ la grammatica definita nell'\cref{exp2}; per poter valutare le sue espressioni in maniera lazy, è necessario ridefinire alcune regole di inferenza definite all'interno dell'\cref{sem op exp}.

        \begin{itemize}
            \item l'insieme degli ambienti di $Exp$ viene ridefinito come segue: $$\mathrm{Env} := \{f \mid \mathrm{Var} \xrightarrow{fin} \mathrm{Val} \cup Exp\}$$ dunque gli ambienti possono associare delle variabili anche a delle espressioni, in modo da poter ritardare la valutazione di quest'ultime fin quando non diventa strettamente necessario valutarle;
            \item $\forall E \subseteq \mathrm{Env}, x \in \mathrm{Var} \quad x \in \dom(E) \land M := E(x) \implies \dfrac{\opjud{E}{M}{v}}{\opjud{E}{x}{v}}$, e questa regola di inferenza include la possibilità di calcolare le variabili il cui valore è associato ad espressioni all'interno dell'ambiente corrente;
            \item $\forall x \in \mathrm{Var}, M, N \in Exp \quad [let] \ \dfrac{\opjud{E\{(x, M)\}}{N}{v}}{\opjud{E}{\letin{x}{M}{N}}{v}}$, in modo da poter ritardare la valutazione dell'espressione $N$ dopo aver valutato $M$.
        \end{itemize}
    \end{framedobs}

    \begin{example}[Valutazione lazy su $Exp$]
        Sia $Exp$ la grammatica definita all'interno dell'\cref{exp2}, e si consideri la seguente espressione $$\letin{x}{M}{x + x}$$ essa, valutata attraverso valutazione lazy, produce il seguente albero di derivazione: $$\dfrac{\dfrac{\dfrac{\dfrac{\ldots}{\opjud{\{(x,M)\}}{M}{v'}}}{\opjud{\{(x, M)\}}{x}{v'}} \quad \dfrac{\dfrac{\ldots}{\opjud{\{(x,M)\}}{M}{v'}}}{\opjud{\{(x, M)\}}{x}{v'}}}{\opjud{\{(x, M)\}}{x+x}{v}}}{\opjud{\varnothing}{\letin{x}{M}{x+x}}{v}}$$ dove $v, v' \in \mathrm{Var} \mid v = v' + v'$. Si noti dunque che è stata valutata prima $M$, poi $x + x$, poiché la seconda espressione dipendeva dal valore della prima.
    \end{example}

    \begin{example}[Valutazione lazy su $Exp$]
        Si consideri l'espressione definita all'interno dell'\cref{eager2}; essa, valutata attraverso valutazione lazy, produce il seguente albero di derivazione: TODO
    \end{example}

    \section{Scoping}

    \subsection{Scoping statico}

    TODO

    \subsection{Scoping dinamico}

    TODO

    \section{Funzioni}

    \subsection{Definizioni}

    \begin{frameddefn}[label={fn}]{Clausola $fn$}
        Sia $G$ una grammatica; allora, è possibile definire su $G$ una funzione $fn$, come segue: $$\func{fn}{\mathrm{Var} \times G}{G}$$ e verrà utilizzata attraverso la sintassi $$\fn{\ttt{*variable*}}{\ttt{\_expression\_}}$$ che restituisce una funzione avente come parametro $\ttt{*variable*}$, il cui valore sarà utilizzato per valutare $\ttt{\_expression\_}$.
    \end{frameddefn}

    \begin{frameddefn}{Applicazione}
        Sia $G$ una grmamatica; allora, dati due suoi termini $M,N$, è possibile definire su $G$ l'applicazione di $M$ ad $N$, attraverso la seguente sintassi: $MN$ Si noti che tale sintassi è presa in prestito dal lambda calcolo.

        Si noti che un'espressione $MNL$ applica prima $M$ ad $N$, e poi $MN$ ad $L$, dunque la precedenza è da sinistra verso destra, ovvero $(MN)L$.
    \end{frameddefn}

    \begin{example}[Grammatica $Fun$]
        \label{fun}
        Sia $Fun$ la seguente estensione della grammatica $Exp$, definita all'interno dell'\cref{exp2}: $$M,N ::= k \ | \ x \ | \ M \ \ttt + \ N \ | \ M \ \ttt * \ N \ | \ \letin{x}{M}{N} \ | \ \fn{x}{M} \ | \ MN$$ Inoltre, l'insiemi dei valori assegnabili alle variabili di $Fun$ verrà esteso come segue $$\mathrm{Val} := \{\ttt 0, \ttt 1, \ldots \} \cup (\mathrm{Var} \times Fun \times Fun)$$ dunque ad una variabile sarà possibile assegnargli il valore che una clausola $let$ restituisce TODO CONTROLLARE SE È GIUSTO
    \end{example}

    \begin{example}[Espressioni su $Fun$]
        Sia $Fun$ la grammatica definita all'interno dell'\cref{fun}, e sia $$(\fn{x}{x +1})7$$ una sua espressione; essa, poiché applica la funzione $\fn{x}{x+1}$ all'espressione 7, viene valutata a $$x = 7 \implies x + 1= 7 + 1 = 8$$
    \end{example}

    \begin{example}[Espressioni su $Fun$]
        Sia $Fun$ la grammatica definita all'interno dell'\cref{fun}, e sia $$(\fn{x}{x3})(\fn{x}{x+1})$$ una sua espressione; essa, una volta valutata, applica la funzione $\fn{x}{x+1}$ all'espressione 3, e dunque il suo valore è pari a $$x = 3 \implies x + 1 = 3 + 1 = 4$$
    \end{example}

    \begin{framedobs}{Curryficazione}
        Si consideri la clausola $fn$ della \cref{fn}; è possibile definirne una notazione contratta, che prende il nome di \tit{curryficazione}, ed è definita come segue: $$\fn{x_1x_2 \ldots x_n}{M} \iff \fn{x_1}{(\fn{x_2}{\ldots (\fn{x_n}{M}) \ldots})}$$ Il processo inverso prende il nome di \tit{uncurryficazione}.
    \end{framedobs}

    \begin{example}[Curryficazioni]
        Sia $Fun$ la grammatica dell'\cref{fun}, e sia $$(\fn{xy}{yx})7(\fn{x}{x+1})$$ una sua espressione; la sua uncurryficazione corrisponde alla seguente espressione $$(\fn{x}{\fn{y}{yx}})7(\fn{x}{x+1})$$ TODO COME SE VALUTA
    \end{example}

\end{document}
