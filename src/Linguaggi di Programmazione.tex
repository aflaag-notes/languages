\documentclass[a4paper, 12pt]{report}

%%%%%%%%%%%%
% Packages %
%%%%%%%%%%%%

\usepackage{../Nyx/nyx-packages}
\usepackage{../Nyx/nyx-styles}
\usepackage{../Nyx/nyx-frames}
\usepackage{../Nyx/nyx-title}
\usepackage{../Nyx/nyx-macros}

%%%%%%%%%%%%%%
% Title-page %
%%%%%%%%%%%%%%

\logo{../Nyx/logo.png}

\institute{\curlyquotes{\hspace{0.25mm}Sapienza} Università di Roma}
\faculty{Ingegneria dell'Informazione,\\Informatica e Statistica}
\department{Dipartimento di Informatica}

\title{Linguaggi di Programmazione}
\subtitle{Appunti integrati con il libro "TODO", TODO 1, Autore 2, ...}

% \author{\textit{Author}\\TODO: DECOMMENTARE QUESTA SEZIONE}
% \author{\textit{Author}\\Simone Bianco}
\author{\textit{Author}\\Alessio Bandiera}
% \supervisor{Linus \textsc{Torvalds}}
% \context{Well, I was bored\ldots}

\date{\today}

%%%%%%%%%%%%
% Document %
%%%%%%%%%%%%

\begin{document}
    \maketitle

    % The following style changes are valid only inside this scope 
    {
        \hypersetup{allcolors=black}
        \fancypagestyle{plain}{%
        \fancyhead{}        % clear all header fields
        \fancyfoot{}        % clear all header fields
        \fancyfoot[C]{\thepage}
        \renewcommand{\headrulewidth}{0pt}
        \renewcommand{\footrulewidth}{0pt}}

        \romantableofcontents
    }

    \chapter*{Informazioni e Contatti}      % \chapter* makes this a "fake" chapter
    \markboth{Informazioni e Contatti}{}    % Manually sets \leftmark (current chapter name)
    \addcontentsline{toc}{chapter}{Informazioni e Contatti}     % Manually adds chapter to ToC
    
    \subsubsection{Prerequisiti consigliati:}
    \begin{itemize}
        \item Algebra
        \item TODO
    \end{itemize}

    \quad

    \subsubsection{Segnalazione errori ed eventuali migliorie:}
    
    Per segnalare eventuali errori e/o migliorie possibili, si prega di utilizzare il \textbf{sistema di Issues fornito da GitHub} all'interno della pagina della repository stessa contenente questi ed altri appunti (link fornito al di sotto), utilizzando uno dei template già forniti compilando direttamente i campi richiesti.

    Gli appunti sono in continuo aggiornamento, pertanto, previa segnalazione, si prega di controllare se l'errore sia ancora presente nella versione più recente.

    \quad

    \subsubsection{Licenza di distribuzione:}
    
    These documents are distributed under the \textbf{\href{https://www.gnu.org/licenses/fdl-1.3.txt}{GNU Free Documentation License}}, a form of copyleft intended to be used on manuals, textbooks or other types of document in order to assure everyone the effective freedom to copy and redistribute it, with or without modifications, either commercially or non-commercially.
    
    \quad

    \subsubsection{Contatti dell'autore e ulteriori link:}
    \begin{itemize}
        % \item TODO: DECOMMENTARE QUESTA SEZIONE

        % Simone
        % 
        % \item Altri appunti: \textbf{\href{https://github.com/Exyss/university-notes}{https://github.com/Exyss/university-notes}}
        % \item Github: \textbf{\href{https://github.com/Exyss}{https://github.com/Exyss}}
        % \item Email: \textbf{\href{mailto:bianco.simone@outlook.it}{bianco.simone@outlook.it}}
        % \item LinkedIn: \textbf{\href{https://www.linkedin.com/in/simone-bianco}{Simone Bianco}}

        % Alessio
        % 
        \item Github: \textbf{\href{https://github.com/ph04}{https://github.com/ph04}}
        \item Email: \textbf{\href{mailto:alessio.bandiera02@gmail.com}{alessio.bandiera02@gmail.com}}
        \item LinkedIn: \textbf{\href{https://www.linkedin.com/in/alessio-bandiera-a53767223/}{Alessio Bandiera}}
    \end{itemize}

    %%%%%%%%%%%%%%%%%%%%%

    \chapter{Induzione}
    
    \section{Algebre induttive}

    \subsection{Assiomi di Peano}

    \begin{frameddefn}[label={peano}]{Assiomi di Peano}
        Gli \tbf{assiomi di Peano} sono 5 assiomi che definiscono l'insieme $\N$, e sono i seguenti:

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $0 \in \N$
            \item $\exists \func{\mathrm{succ}}{\N}{\N}$, o equivalentemente, $\forall x \in \N \quad \mathrm{succ}(x) \in \N$
            \item $\forall x, y \in \N \quad x \neq y \implies \mathrm{succ}(x) \neq \mathrm{succ}(y)$
            \item $\nexists x \in \N \mid \mathrm{succ}(x) = 0$
            \item $\forall S \subseteq \N \quad (0 \in S \land (\forall x \in S \quad \mathrm{succ}(x) \in S)) \implies S = \N$
        \end{enumerate}
    \end{frameddefn}

    \begin{example}[$\N$ di von Neumann]
        Una rappresentazione dell'insieme dei numeri naturali $\N$ alternativa alla canonica $$\N := \{0, 1, 2, \ldots \}$$ è stata fornita da John von Neumann. Indicando tale rappresentazione con $\aleph$, si ha che, per Neumann $$\begin{array}{c} 0_\aleph := \varnothing  = \{\} \\ 1_\aleph := \{ 0_\aleph \} = \{ \{ \}\} \\ 2_\aleph := \{0_\aleph, 1_\aleph\} = \{\{\}, \{\{ \}\}\} \\ \vdots \end{array}$$ e la funzione $\mathrm{succ}_\aleph$ è definita come segue $$\funcmap{\mathrm{succ}_\aleph}{\aleph}{\aleph}{x_\aleph}{x_\aleph \cup \{x_\aleph\} = \{\mu_\aleph \in \aleph \mid |\mu_\aleph| \le |x_\aleph|\}}$$ ed in particolare $\forall x_\aleph \in \aleph \quad |x_\aleph| + 1 = |\mathrm{succ}_\aleph(x_\aleph)|$.

        È possibile verificare che tale rappresentazione di $\N$ soddisfa gli assiomi di Peano, in quanto

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $0_\aleph := \varnothing \in \aleph$;
            \item $\exists \func{\mathrm{succ}_\aleph}{\aleph}{\aleph}$, definita precedentemente;
            \item $\forall x_\aleph, y_\aleph \in \aleph \quad x_\aleph \neq y_\aleph \implies |x_\aleph| \neq |y_\aleph| \implies  |\mathrm{succ}_\aleph(x_\aleph)| \neq |\mathrm{succ}_\aleph(y_\aleph)| \implies \mathrm{succ}_\aleph(x_\aleph) \neq \mathrm{succ}_\aleph(y_\aleph)$;
            \item per assurdo, sia $x_\aleph \in \aleph$ tale che $\mathrm{succ}_\aleph(x_\aleph) = 0_\aleph := \varnothing$; per definizione $\mathrm{succ}_\aleph(x_\aleph) := \{\mu_\aleph \in \aleph \mid |\mu_\aleph| \le |x_\aleph|\}$, ma non esiste $\mu_\aleph \in \aleph$ con cardinalità minore o uguale 0, e dunque $\nexists x_\aleph \in \aleph \mid \mathrm{succ}_\aleph(x_\aleph) = 0_\aleph$;
            \item per assurdo, sia $S \subseteq \aleph$ tale che $0_\aleph \in S$ e $\forall x_S \in S \quad \mathrm{succ}_\aleph(x_S) \in S$ ma $S \neq \aleph \iff \aleph - S \neq \varnothing \implies \exists \zeta_\aleph \in \aleph - S$, ed in particolare $\zeta_\aleph \neq 0_\aleph$; $\aleph$ è chiuso su $\mathrm{succ}_\aleph$ per il secondo assioma di Peano, e dunque $\zeta_\aleph \neq 0_\aleph \implies \exists \zeta'_\aleph \in \aleph \mid \mathrm{succ}_\aleph(\zeta'_\aleph) = \zeta_\aleph$, e sicuramente $\zeta'_\aleph \notin S$, poiché altrimenti $\zeta_\aleph \in S$ anch'esso in quanto $S$ è chiuso rispetto a $\mathrm{succ}_\aleph$; allora, ripetendo il ragionamento analogo per l'intera catena di predecessori, $S$ risulterebbe essere vuoto, ma ciò è impossibile poiché $0_\aleph \in S$ in ipotesi $\lightning$.
        \end{enumerate}
    \end{example}

    \begin{framedprinc}[label={induction}]{Principio di Induzione}
        Sia $P$ una proprietà che vale per $n = 0$, e dunque $P(0)$ è vera; inoltre,  per ogni $n \in \N$ si ha che $P(n) \implies P(n + 1)$; allora, $P(n)$ è vera per ogni $n \in \N$.

        In simboli, utilizzando la notazione della logica formale, si ha che $$\dfrac{P(0) \quad \dfrac{\forall n \in \N \quad P(n)}{P(n + 1)}}{\forall n \in \N \quad P(n)}$$
    \end{framedprinc}

    \begin{framedobs}{Quinto assioma di Peano}
        Si noti che il quinto degli assiomi di Peano (\cref{peano}) equivale al principio di induzione (\cref{induction}). Infatti, il quinto assioma afferma che qualsiasi sottoinsieme $S$ di $\N$ avente lo 0, e caratterizzato dalla chiusura sulla funzione di successore $\mathrm{succ}$, coincide con $\N$ stesso.
    \end{framedobs}

    \subsection{Algebre induttive}

    \begin{frameddefn}{Segnatura di una funzione}
        Data una funzione $f$, si definisce $$\func{f}{A}{B}$$ come \tbf{segnatura della funzione} $f$, dove $A$ è detto \tbf{dominio}, denotato con $\dom{(f)}$ e $B$ \tbf{codominio} di $f$.
    \end{frameddefn}

    \begin{frameddefn}{Algebra}
        Una \tbf{struttura algebrica}, o più semplicemente \tbf{algebra}, consiste di un insieme \tit{non vuoto}, talvolta chiamato \tbf{insieme sostegno} (\tit{carrier set} o \tit{domain}), fornito di una o più operazioni su tale insieme, quest'ultime caratterizzate da un numero finito di assiomi da soddisfare.

        Se $A$ è il carrier set, e $\gamma_1, \ldots \gamma_n$ sono delle operazioni definite su $A$, allora con $$(A, \gamma_1, \ldots, \gamma_n)$$ si indica l'algebra costituita da tali componenti, e questo simbolismo prende il nome di \tbf{segnatura dell'algebra}.
    \end{frameddefn}

    \begin{example}[Strutture algebriche con singola operazione]
        Esempi di strutture algebriche con un'operazione binaria sono i seguenti:

        \begin{itemize}
            \item semigruppi
            \item monoidi
            \item gruppi
            \item gruppi abeliani
        \end{itemize}
    \end{example}

    \begin{example}[Strutture algebriche con due operazioni]
        Esempi di strutture algebriche con due operazioni binarie sono i seguenti:

        \begin{itemize}
            \item semianelli
            \item anelli
            \item campi
        \end{itemize}
    \end{example}

    \begin{frameddefn}{Insieme unità}
        Con \tbf{insieme unità} si intende un qualsiasi insieme tale che $\abs{\1} = 1$, e verrà indicato attraverso il simbolo $\1$.
    \end{frameddefn}

    \begin{frameddefn}{Funzione nullaria}
        Dato un insieme A, con \tbf{funzione nullaria} si intende una qualsiasi funzione con segnatura $$\func{f}{\1}{A}$$
    \end{frameddefn}

    \begin{framedobs}[label={inj null}]{Iniettività della funzione nullaria}
        Si noti che ogni funzione nullaria è iniettiva, poiché il dominio è costituito da un solo elemento.
    \end{framedobs}

    \begin{frameddefn}[label={inductive algebra}]{Algebra induttiva}
        Sia $A$ un insieme, e siano $\gamma_1, \ldots, \gamma_n$ funzioni definite su $A$ di arbitraria arietà; allora, $(A, \gamma_1, \ldots, \gamma_n)$ è definita \tbf{algebra induttiva} se si verificano le seguenti:

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $\gamma_1, \ldots, \gamma_n$ sono iniettive
            \item $\forall i, j \in [1, n] \mid i \neq j \quad \im(\gamma_i) \cap \im(\gamma_j) = \varnothing$, ovvero, le immagini dei costruttori sono a due a due disgiunte
            \item $\forall S \subseteq A \quad (\forall i \in [1, n], a_1, \ldots a_k \in S, k \in \N  \quad \gamma_i(a_1, \ldots, a_k) \in S) \implies S = A$, o equivalentemente, in $A$ non devono essere contenute algebre induttive.
        \end{enumerate}

        Le funzioni $\gamma_1, \ldots, \gamma_n$ prendono il nome di \tbf{costruttori dell'algebra}.
    \end{frameddefn}

    \begin{framedobs}[label={third inductive algebra}]{Terzo assioma delle algebre induttive}
        Si noti che nel terzo assioma della \cref{inductive algebra} anche $S = \varnothing$ è un valido sottoinsieme di $A$, ma poiché non esistono $a_1, \ldots, a_k \in \varnothing$, in esso ogni qualificazione è vera a vuoto. Di conseguenza, nel momento in cui si ammette $S = \varnothing$ nel terzo assioma, l'algebra risulta essere non induttiva necessariamente (a meno dell'algebra vuota).
        
        Di conseguenza, questo terzo assioma forza la necessità della presenza di un costruttore nullario all'interno di ogni algebra induttiva, in modo da non poter ammettere $S = \varnothing$, poiché l'algebra deve essere chiusa su ognuno dei suoi costruttori.
    \end{framedobs}

    \begin{example}[Numeri naturali]
        $(\N, +)$ non è un algebra induttiva, poiché esistono $x_1, x_2, x_3, x_4 \in \N$ con $x_1 \neq x_3$ e $x_2 \neq x_4$ tali che $x_1 + x_2 = x_3 + x_4$; ad esempio, 2 + 3 = 5 = 1 + 4, e 2 $\neq$ 1, 3 $\neq$ 4.
    \end{example}

    \begin{example}[Algebra di Boole]
        Dato l'insieme $B = \{ \mathrm{true}, \mathrm{false}\}$, e la funzione $\lnot$ definita come segue $$\funcmap{\lnot}{B}{B}{x}{\left \{ \begin{array}{ll} \mathrm{false} & x = \mathrm{true} \\ \mathrm{true} & x = \mathrm{false} \end{array} \right.}$$ è possibile dimostrare che l'algebra $(B, \lnot)$ non è induttiva; infatti, nonostante $\lnot$ sia iniettiva, e la seconda proprietà della \cref{inductive algebra} sia vera a vuoto, $(B, \lnot)$ non presenta costruttore nullario, e dunque non può costituire un'algebra induttiva (si noti l'\cref{third inductive algebra}).
    \end{example}

    \begin{example}[Algebre induttive]
        Sia $\mathrm{zero}$ la funzione definita come segue $$\funcmap{\mathrm{zero}}{\1}{\N}{x}{0}$$ e si prenda in esame l'algebra $(\N, \mathrm{succ}, \mathrm{zero})$; allora si ha che

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item $\mathrm{succ}$ e $\mathrm{zero}$ sono iniettive, poiché
                \begin{itemize}
                    \item $\mathrm{succ}$ è iniettiva per il terzo assioma di Peano (\cref{peano})
                    \item $\mathrm{zero}$ è iniettiva per l'\cref{inj null}
                \end{itemize}
            \item $\im(\mathrm{succ}) \cap \im(\mathrm{zero}) = \left(\N - \{0\}\right) \cap \{0\} = \varnothing$
            \item TODO
        \end{enumerate}
    \end{example}

    \begin{frameddefn}{Omomorfismo}
        Un \tbf{omomorfismo} è una funzione, tra due algebre dello stesso tipo, tale da preservarne le strutture.

        Formalmente, siano $(A, \mu_1, \ldots, \mu_n)$ e $(B, \delta_1, \ldots, \delta_n)$ due algebre tali che ogni funzione $\mu_i$ abbia la stessa arietà e lo stesso numero di parametri esterni (denotati con $k$) di $\delta_i$, pari rispettivamente ad $\eta_i$ ed a $\nu_i$, per qualche $i \in [1, n]$; allora, una funzione $\func{f}{A}{B}$ è detta essere un \tbf{omomorfismo} tra le due algebre, se e solo se $$\begin{array}{c} \forall a_1, \ldots, a_{\eta_1} \quad f(\mu_1(a_1, \ldots, a_{\eta_n}), k_1, \ldots, k_{\nu_1}) = \delta_1(f(a_1), \ldots, f(a_{\eta_1}), k_1, \ldots, k_{\nu_1}) \\ \vdots \\ \forall a_1, \ldots, a_{\eta_n} \quad f(\mu_n(a_1, \ldots, a_{\eta_n}), k_1, \ldots, k_{\nu_n}) = \delta_n(f(a_1), \ldots, f(a_{\eta_n}), k_1, \ldots, k_{\nu_n}) \end{array}$$
    \end{frameddefn}

    \begin{example}[Omomorfismi]
        \label{homo}
        Si considerino i gruppi $(\R, +)$ e $(\R_{> 0}, \cdot)$, e sia $f$ definita come segue: $$\funcmap{f}{\R}{\R_{> 0}}{x}{e^x}$$ allora, si ha che $$\forall x, y \in \R \quad f(x) \cdot f(y) = e^x \cdot e^y = e^{x + y} = f(x + y)$$ dunque $f$ è un omomorfismo di gruppi.
    \end{example}

    \begin{frameddefn}{Isomorfismo}
        Un \tbf{isomorfismo} è un omomorfismo biettivo.
    \end{frameddefn}

    \begin{example}[Isomorfismi]
        Si consideri l'omomorfismo dell'\cref{homo}; si noti che $$\forall x, y \in \R \mid x \neq \R \quad e^x \neq e^y \implies f(x) \neq f(y)$$ e dunque $f$ è iniettiva; inoltre $$\forall y \in \R_{> 0} \quad \exists x \in \R \mid f(x) = e^x = y \iff y = \ln(x)$$ e dunque $f$ è suriettiva. Allora, $f$ è biettiva, e poiché è un omomorfismo, risulta essere un isomorfismo.
    \end{example}

    \section{Strutture dati induttive}

    \subsection{Liste}

    \begin{frameddefn}{Liste}
        Una \tbf{lista} è una collezione ordinata di elementi, e l'insieme delle liste di lunghezza finita viene denotato con $\ttt{List<T>}$, dove $\ttt T$ è il tipo degli elementi che le liste contengono, ed il simobolo $\ttt T$ verrà identificato con l'insieme di tutti gli oggetti aventi tipo $\ttt T$.

        Dati $a_1, \ldots, a_n \in \ttt T$, una lista $l \in \ttt{List<T>}$ contenente tali elementi può essere rappresentata come segue: $$\ttt [ a_1, \ldots, a_n \ttt ]$$
    \end{frameddefn}

    \begin{frameddefn}{Algebra delle liste finite}
        L'\tbf{algebra delle liste finite} è definita come segue: $$(\ttt{List<T>}, \mathrm{empty}, \mathrm{cons})$$ dove i costruttori sono i seguenti: $$\centeredsoe{\funcmap{\mathrm{empty}}{\1}{\ttt{List<T>}}{x}{\ttt{[]}} \\ \funcmap{\mathrm{cons}}{\ttt{List<T>} \times \ttt{T}}{\ttt{List<T>}}{(\ttt [ a_1, \ldots, a_n \ttt ], x)}{\ttt [ a_1, \ldots, a_n , x \ttt ]}}$$
    \end{frameddefn}

    \begin{framedprop}[label={alf induttiva}]{Liste finite induttive}
        L'algebra delle liste finite è induttiva.
    \end{framedprop}

    \begin{proof}
        Si noti che:

        \begin{itemize}
            \item $\mathrm{empty}$ ha dominio in $\1$, e poiché questo contiene un solo elemento, $\mathrm{empty}$ è necessariamente iniettiva;
            \item $\forall l, l' \in \ttt{List<T>}, x, x' \in \ttt{T} \quad \mathrm{cons}(l, x) = \mathrm{cons}(l', x') \implies \soe{l}{l = l' \\ x = x'}$ altrimenti $l$ ed $l'$ avrebbero avuto lunghezze diverse, oppure avrebbero contenuto diversi elementi;
            \item $\im{(\mathrm{empty})} \cap \im{(\mathrm{cons})} = \varnothing$, poiché solo $\mathrm{empty}$ può restituire $\ttt [ \ttt ]$, in quanto $\mathrm{cons}$ restituisce sempre una lista contenente almeno l'elemento fornito in input;
            \item sia $S \subseteq \ttt{List<T>}$ tale da essere chiuso rispetto a $\mathrm{cons}$, e contenente la lista vuota; per assurdo, sia $\ttt{List<T>} - S \neq \varnothing \implies \exists l \in \ttt{List<T>} - S$, ma $\ttt{List<T>}$ è chiuso rispetto a $\mathrm{cons}$, ed in particolare $\exists x \in \ttt{T}, l' \in \ttt{List<T>} \mid \mathrm{cons}(l', x) = l$, ma poichè $l \notin S$, allora necessariamente $l' \notin S$, poiché $S$ è chiuso rispetto a $\mathrm{cons}$, e quindi $l' \in S \implies l \in S$, ma $l$ è stato scelto in $\ttt{List<T>} - S$; ripetendo tale ragionamento induttivamente, si ottiene che $S$ è vuoto, ma questo è impossibile poiché $\ttt{[]} \in \ttt{List<T>}$ in ipotesi $\lightning$.
        \end{itemize}

        Dunque, l'algebra delle liste finite risulta essere induttiva.
    \end{proof}

    \begin{framedobs}[label={infinite lists}]{Algebra delle liste infinite}
        Se all'algebra delle liste finite venissero aggiunte anche le liste infinite, l'algebra risultante non sarebbe induttiva, in quanto conterrebbe l'algebra delle liste finite, la quale è induttiva per la \cref{alf induttiva}, e verrebbe dunque contraddetto il terzo assioma della \cref{inductive algebra}.
    \end{framedobs}

    \begin{framedobs}{Concatenazione di liste finite}
        È possibile estendere l'algebra delle liste finite per supportare l'operazione di concatenazione tra liste, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{concat}}{\ttt{List<T>} \times \ttt{List<T>}}{\ttt{List<T>}}{(l, l')}{\soe{ll}{l' & l = \ttt{[]} \\ \mathrm{cons}(x, \mathrm{concat}(t, l')) & \exists x \in \ttt T, t \in \ttt{List<T>} \mid l = \mathrm{cons}(t, x)}}$}
    \end{framedobs}

    \subsection{Alberi binari}

    \begin{frameddefn}{Albero binario}
        Un \tbf{albero binario} è una struttura dati che è possibile rappresentare graficamente come segue:

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[
                    level distance=1cm,
                    level 1/.style={sibling distance=2cm},
                    level 2/.style={sibling distance=1cm}
                ]
                \node {$\circ$}
                    child {node {$\circ$}
                    child {node {$\circ$}}
                    child {node {$\circ$}}
                }
                    child {node {$\circ$}
                };
            \end{tikzpicture}
        \end{figure}

        Il primo nodo, poiché non è figlio di nessuno, è detto \tbf{radice}, e poiché l'albero è \tit{binario}, ogni nodo ha 0 --- nel qual caso è definito \tbf{foglia} --- oppure 2 figli. L'insieme degli alberi binari viene denotato con \ttt{B-tree}.
    \end{frameddefn}

    \begin{frameddefn}{Algebra degli alberi binari finiti}
        L'\tbf{algebra degli alberi binari finiti} è definita come segue: $$(\ttt{B-tree}, \mathrm{leaf}, \mathrm{branch})$$ dove i costruttori sono i seguenti:

        $$\funcmap{\mathrm{leaf}}{\1}{\ttt{B-tree}}{x}{\circ}$$

        \begin{center}
            \begin{tabular}{c c}
                \begin{tabular}{c}$\funcmap{\mathrm{branch}}{\ttt{B-tree} \times \ttt{B-tree}}{\ttt{B-tree}}{(b, b')}{}$\end{tabular}
                &
                \begin{tabular}{c}
                    \begin{tikzpicture}[
                            level distance=1cm,
                            level 1/.style={sibling distance=1cm},
                        ]
                        \node {$\circ$}
                            child {node {$b$}
                        }
                            child {node {$b'$}
                        };
                    \end{tikzpicture}
                \end{tabular}
            \end{tabular}
        \end{center}
    \end{frameddefn}

    \begin{framedprop}{Alberi binari finiti induttivi}
        L'algebra degli alberi binari finiti è induttiva.
    \end{framedprop}

    \begin{proof}
        Omessa.
    \end{proof}

    \begin{framedobs}{Algebra degli alberi binari infiniti}
        Analogamente all'\cref{infinite lists}, l'algebra degli alberi binari finiti ed infiniti non è induttiva.
    \end{framedobs}

    \begin{framedobs}{Nodi di un albero binario finito}
        È possibile estendere l'algebra degli alberi binari finiti per supportare l'operazione per contare i nodi di un albero, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{nodes}}{\ttt{B-tree}}{\N}{b}{\soe{ll}{1 & b = \circ \\ 1 + \mathrm{nodes}(t) + \mathrm{nodes}(t')  & \exists t, t' \in \ttt{B-tree} \mid b = \mathrm{branch}(t, t')}}$}
    \end{framedobs}

    \begin{framedobs}{Foglie di un albero binario finito}
        È possibile estendere l'algebra degli alberi binari finiti per supportare l'operazione per contare le foglie di un albero, come segue: $$\funcmap{\mathrm{leaves}}{\ttt{B-tree}}{\N}{b}{\soe{ll}{1 & b = \circ \\ \mathrm{leaves}(t) + \mathrm{leaves}(t') & \exists t, t' \in \ttt{B-tree} \mid b = \mathrm{branch}(t, t')}}$$
    \end{framedobs}

    \begin{framedthm}{Relazione tra foglie e nodi}
        Ogni albero binario finito, avente $n$ foglie, ha $2n - 1$ nodi.
    \end{framedthm}

    \proofind{
        La seguente dimostrazione procede per \tit{induzione strutturale}, dunque effettuando l'induzione sulla morfologia della struttura dati, e non sul numero $n$ di foglie.
    }{
        Il caso base è costituito dunque da $\circ$, l'albero ottenuto attraverso il costruttore nullario $\mathrm{leaf}$, ed infatti si ha che $$\mathrm{leaves}(\circ) = 1 \implies 2 \cdot 1 - 1 = 1$$ e $\circ$ ha esattamente 1 nodo.
    }{
        Un albero binario finito, avente $n$ foglie, ha $2n - 1$ nodi.
    }{
        Sia $b \in \ttt{B-tree}$ tale che esistano $t, t' \in \ttt{B-tree}$ tali che $\mathrm{branch}(t, t') = b$, e siano $$\soe{l}{\mathrm{leaves}(t) = n \\ \mathrm{leaves}(t') = n'}$$ Si noti che, per ipotesi induttiva, si ha che $$\soe{l}{\mathrm{nodes}(t) = 2n - 1 \\ \mathrm{nodes}(t') = 2n' - 1}$$ ed inoltre, poiché $b = \mathrm{branch}(t, t')$, $b$ ha la forma seguente

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[
                    level distance=1cm,
                    level 1/.style={sibling distance=1cm},
                ]
                \node {$\circ$}
                    child {node {$t$}
                }
                    child {node {$t'$}
                };
            \end{tikzpicture}

        \end{figure}
        dunque, per definizione di $\mathrm{leaves}$ si ha che $$\mathrm{leaves}(b) = \mathrm{leaves}(t) + \mathrm{leaves}(t') = n + n'$$ e, dalla morfologia di $b$, segue che $$\mathrm{nodes}(b) = \mathrm{nodes}(t) + \mathrm{notes}(t') + 1 = 2n -1 + 2n'-1 + 1 = 2(n + n') - 1$$ ed è quindi verificata la tesi, poiché $$\mathrm{leaves}(b) = n + n' \implies \mathrm{nodes}(b) = 2(n + n') - 1$$
    }
    
    \chapter{Paradigma funzionale}

    \section{Grammatiche}
    
    \subsection{Definizioni}

    \begin{frameddefn}{Grammatica}
        Una \tbf{grammatica} è un insieme di regole che definiscono come manipolare un insieme di stringhe, agendo su elementi sintattici detti \tbf{termini}.
    \end{frameddefn}

    \begin{frameddefn}{Forma di Backus-Naur (BNF)}
        La \tbf{forma di Backus-Naur} (\tit{Backus-Naur Form}) è una notazione utilizzata per descrivere la sintassi di grammatiche, ed è definita come segue: $$\ttt{<symbol>}, \ldots, \ttt{<symbol>} ::= \ttt{\_expression\_} \ | \ \ldots \ | \ \ttt{\_expression\_}$$ dove
        \begin{itemize}
            \item $\ttt{<symbol>}$ è una \tit{metavariabile non terminale}, ovvero, può essere sostituita con regole definite dalla grammatica; si noti che le regole possono essere utilizzate \und{ricorsivamente};
            \item il simbolo $::=$ indica che ciò che è posto alla sua sinistra deve essere sostituito con ciò che è alla sua destra;
            \item $\ttt{\_expression\_}$ è un espressione che verrà usata per rimpiazzare le metavariabili non terminali, attraverso le regole definite dalla grammatica; le \tit{metavarabili} che compongono le espressioni possono essere \tbf{costanti}, \tbf{variabili}, \tbf{termini} o \tbf{espressioni} contenenti combinazioni delle precedenti, presentando eventualmente anche operazioni sintattiche specifiche.
        \end{itemize}
    \end{frameddefn}

    \begin{example}[Grammatica $Exp$]
        \label{exp}
        Sia $Exp$ la seguente grammatica: $$M, N ::= \ttt 0 \ | \ \ttt 1 \ | \ldots \ | \ x \ | \ M \ \ttt + \ N \ | \ M \ \ttt * \ N$$ essa definisce le regole per utilizzare i numeri in $\N$, ammettendo inoltre le operazioni \und{sintattiche} di $\ttt +$ e $\ttt *$.

        All'interno di questa grammatica dunque, le metavariabili utilizzate sono le seguenti:
        \begin{itemize}
            \item \tit{costanti}: $\ttt 0, \ttt 1,  \ldots$
            \item \tit{variabili}: $x$
            \item \tit{termini}: $M$ ed $N$
            \item \tit{espressioni}: $M \ \ttt + \ N$ e $M \ \ttt * \ N$ (tecnicamente anche le precedenti sono espressioni, ma queste in particolare comprendono anche operazioni sintattiche)
        \end{itemize}
    \end{example}

    \begin{frameddefn}{Variabili}
        Data una grammatica di $G$, con $\mathrm{Var}$ si indica l'\tbf{insieme delle variabili} di $G$.
    \end{frameddefn}

    \begin{frameddefn}{Valori}
        Data una grammatica, con $\mathrm{Val}$ si indica l'\tbf{insieme dei valori} che ogni termine della grammatica può assumere.
    \end{frameddefn}

    \begin{example}[Variabili e valori di $Exp$]
        Si prenda in considerazione la grammatica $Exp$ dell'\cref{exp2}; in essa, si ha che $$\centeredsoe{\mathrm{Var} = \{ x \} \\ \mathrm{Val} = \{ \ttt 0, \ttt 1, \ldots \}}$$
    \end{example}

    \begin{frameddefn}{Linguaggio di una grammatica}
        Sia $G$ una grammatica; allora, il suo \tbf{linguaggio} è l'insieme delle stringhe che è possibile costruire attraverso le regole dettate da $G$.
    \end{frameddefn}

    \begin{example}[Linguaggio di $Exp$]
        Sia $Exp$ la grammatica dell'\cref{exp}; in essa, considerando ad esempio le stringhe $\ttt{"4"}$ e $\ttt{"23"}$, si può ottenere la stringa $$\ttt{+}(\ttt{"4"}, \ttt{"23"}) = \ttt{"4 + 23"}$$ dove la \tit{polish notation} --- alla sinistra dell'uguale --- e la forma sintattica canonica --- alla sua destra --- verranno utilizzate intercambiabilmente, poiché puro \tit{syntactic sugar}.
    \end{example}

    \begin{framedobs}[label={eval}]{Valutazione di $Exp$}
        Si prenda in considerazione la grammatica $Exp$ dell'\cref{exp}; su di essa, è possibile definire ricorsivamente una funzione $\mathrm{eval}$, in grado di valutare le stringhe che tale grammatica può produrre, come segue: $$\centeredsoe{\mathrm{eval}(\ttt 0) = \ttt 0 \\ \mathrm{eval}(\ttt 1) = \ttt 1 \\ \vdots \\ \mathrm{eval}(M \ \ttt + \ N) = \mathrm{eval}(M) \ \ttt + \ \mathrm{eval}(N) \\ \mathrm{eval}(M \ \ttt * \ N) = \mathrm{eval}(M) \ \ttt * \ \mathrm{eval}(N)}$$
    \end{framedobs}

    \begin{framedobs}[label={ambiguity}]{Ambiguità di $Exp$}
        Si prenda in considerazione la grammatica $Exp$ dell'\cref{exp}; si noti che tale grammatica è ambigua, poichè ad esempio $$\ttt{+}(\ttt{"5"}, \ttt{*}(\ttt{"6"}, \ttt{"7"})) = \ttt{"5 + 6 * 7"} = \ttt{*}(\ttt{+}(\ttt{"5"}, \ttt{"6"}), \ttt{"7"})$$ e da ciò segue anche che $\im{(\ttt+)} \cap \im{(\ttt *)} \neq \varnothing$.
    \end{framedobs}

    \begin{framedobs}{Disambiguazione di $Exp$}
        Si noti che l'ambiguità trattata nell'\cref{ambiguity} non permetterebbe di poter definire la funzione $\mathrm{eval}$, descritta nell'\cref{eval}. Dunque, per risolvere tale ambiguità, a meno di parentesi (che \tit{non} sono definite all'interno della grammatica) o dell'esplicitazione della composizione di funzioni utilizzata, verrà sottintesa la normale precedenza degli operatori aritmetica durante la valutazione delle stringhe.
    \end{framedobs}

    \section{Assegnazioni}

    \subsection{Definizioni}

    \begin{frameddefn}[label={let}]{Clausola $let$}
        Sia $G$ una grammatica; allora, è possibile definire su $G$ una funzione \tbf{$let$}, come segue: $$\func{let}{\mathrm{Var} \times G \times G}{G}$$ e verrà utilizzata attraverso la sintassi $$\letin{\ttt{*variable*}}{\ttt{\_expression\_}_1}{\ttt{\_expression\_}_2}$$ dove alla variabile $\ttt{*variable*}$ verrà assegnata l'espressione $\ttt{\_expression\_}_1$ \tit{durante la valutazione} di $\ttt{\_expression\_}_2$; la variabile $\ttt{*variable*}$, all'interno di $\ttt{\_expression\_}_2$, prende il nome di \tbf{variabile locale}.

        Una variabile alla quale non è stata assegnata nessuna espressione prende il nome di \tbf{variable libera} (\tit{free variable} in inglese); una variabile non libera è detta \tbf{variabile legata} (\tit{bound variable}). L'azione di legare o liberare una variabile è detta \tbf{variable binding}.
    \end{frameddefn}
    
    \begin{example}[Estensione di $Exp$]
        \label{exp2}
        Sia $Exp$ la seguente estensione della grammatica presente all'interno dell'\cref{exp}: $$M, N ::= k \ | \ x \ | \ M \ \ttt + \ N \ | \ M \ \ttt * \ N \ | \ \letin{x}{M}{N}$$

        In essa, sono presenti:

        \begin{itemize}
            \item \tit{costanti}: indicate con $k$, che sta ad indicare che in $Exp$ è ammessa qualsiasi costante; di fatto, è possibile pensare a $k$ come una funzione definita come segue: $$\funcmap{k}{\N}{Exp}{x}{\ttt{"x"}}$$
            \item \tit{variabili}: $x$
            \item \tit{termini}: $M$ ed $N$
            \item \tit{espressioni}: $M \ \ttt + \ N$, $M \ \ttt * \ N$ e $\letin{x}{M}{N}$
        \end{itemize}
    \end{example}

    \begin{example}[Clausole $let$]
        Sia $Exp$ la grammatica dell'\cref{exp2}; un esempio di espressione su $Exp$, che utilizza la clausola $let$ della \cref{let}, è la seguente: $$\letin{x}{3}{(x + 1)}$$ e nel momento in cui viene valutata tale espressione, si ha che $$x = 3 \implies x + 1 = 3 + 1 = 4$$ e dunque il valore dell'espressione è 4.
    \end{example}

    \begin{example}[Variabili libere]
        Sia $Exp$ la grammatica dell'\cref{exp2}, ed ammettendo la variabile $y$ in essa, si consideri la seguente espressione: $$\letin{x}{3}{(x + y)}$$ in essa, la variabile $x$ è posta pari a 3, ma ad $y$ non è stato assegnato alcuna espressione, e dunque risulta essere una variabile libera.
    \end{example}

    \begin{framedobs}{Ambiguità di $let$}
        Sia $Exp$ la grammatica dell'\cref{exp2}, e si consideri la sua seguente espressione $$\letin{x}{M}{x + y}$$ per qualche espressione $M \in Exp$, e due variabili $x, y \in \mathrm{Var}$, ammettendo dunque $y$ tra le variabili di $Exp$; si noti che tale espressione è ambigua, poiché potrebbe equivalere a $$(\letin{x}{M}{x}) + y$$ oppure a $$\letin{x}{M}{(x + y)}$$ Per convenzione, all'interno di questi appunti, in assenza di parentesi che descrivano la precedenza degli operatori, si assume la precedenza della seconda espressione mostrata.
    \end{framedobs}

    \begin{framedobs}{Variabili libere di $Exp$}
        Sia $Exp$ la grammatica dell'\cref{exp2}; su di essa, è possibile definire, ricorsivamente, una funzione in grado di restituire le variabili free di una data espressione, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{free}}{Exp}{\powerset{\left(\mathrm{Var}\right)}}{e}{\soe{ll}{
            \varnothing & \exists \eta \in \N \mid e = k(\eta) \\ 
            \{x\} & \exists x \in \mathrm{Var} \mid e = x \\ 
            \mathrm{free}(M) \cup \mathrm{free}(N) & \exists M, N \in Exp \mid e = M \ \ttt + \ N \lor e = M \ \ttt * \ N \\
            \mathrm{free}(M) \cup (\mathrm{free}(N) - \{x\}) & \exists x \in \mathrm{Var}, M, N \in Exp \mid e = (\letin{x}{M}{N})
        }}$}
    \end{framedobs}

    \subsection{Ambienti}
    
    \begin{frameddefn}[label={env}]{Ambiente di una grammatica}
        Data una grammatica tale che $\mathrm{Val}$ sia un insieme finito, un \tbf{ambiente} della grammatica è una funzione della forma $$E: \mathrm{Var} \xrightarrow{fin} \mathrm{Val}$$ che associa dunque una variabile ad un possibile valore che può assumere (la notazione $fin$ indica che $E$ è una funzione \tit{parziale}, dunque non necessariamente definita su tutto il dominio). L'insieme di tutti gli ambienti della grammatica è denotato con $$\mathrm{Env} := \{f \mid f : \mathrm{Var} \xrightarrow{fin} \mathrm{Val} \}$$

        In simboli, gli ambienti verranno scritti come insiemi di coppie $(x, k)$ con $x \in \mathrm{Var}, k \in \mathrm{Val}$, che descriveranno la mappa definita dall'ambiente stesso. Si noti che, per un certo ambiente $E \in \mathrm{Env}$, $E(x)$ è indefinito per ogni $x \in \mathrm{Var} - \dom(E)$.
    \end{frameddefn}

    \begin{example}[Ambienti di $Exp$]
        Sia $Exp$ la grammatica dell'\cref{exp2}; allora, un possibile ambiente di $Exp$, denotato con $E \in \mathrm{Env}$, è il seguente: $$E := \{(z,3), (y, 9) \}$$ ed esso esprime la possibilità che in $Exp$ $z$ possa essere valutato pari a 3, mentre $y$ pari a 9 (tecnicamente, le variabili $z$ ed $y$ andrebbero ammesse all'interno della grammatica, ma d'ora in avanti tale precisazione verrà sottintesa).
    \end{example}

    \begin{frameddefn}{Concatenazione di ambienti}
        Siano $E_1$ ed $E_2$ due ambienti di una grammatica; allora, si definisce \tbf{concatenazione} di $E_1$ ed $E_2$ la seguente funzione $$E_1E_2: \mathrm{Env} \times \mathrm{Env} \to \mathrm{Env} : x \mapsto \soe{ll}{E_2 & x \in \dom{(E_2)} \lor x \in \dom{(E_1)} \cap \dom{(E_2)} \\ E_1(x) & x \in \dom{(E_1)}}$$ dunque, nella concatenazione $E_2$ sovrascrive le tuple che sono presenti anche in $E_1$.
    \end{frameddefn}

    \begin{example}[Concatenazioni di ambienti]
        Sia $Exp$ la grammatica descritta all'interno del \cref{exp2}, e siano $$\centeredsoe{E_1 := \{(z, 3), (y, 9)\} \\ E_2 := \{(z, 4)\}}$$ due suoi ambienti; allora si ha che $$E_1E_2 := \{(z, 4), (y, 9)\}$$
    \end{example}

    \subsection{Semantica operazionale}

    \begin{frameddefn}[label={sem opexp}]{Semantica operazionale di una grammatica}
        Data una grammatica $G$, si definisce \tbf{semantica operazionale} della grammatica una relazione, indicata col simbolo $\leadsto$, definita come segue: $$\leadsto \ \subseteq \mathrm{Env} \times G \times \mathrm{Val}$$

        Un elemento $(E, M, v) \in \ \leadsto$ è detto \tbf{giudizio operazionale}, e viene scritto attraverso il seguente simbolismo: $$\opjud{E}{M}{v}$$ e si legge "valutando $M$, nell'ambiente $E$, si ottiene $v$".
    \end{frameddefn}

    \begin{example}[Semantica operazionale di $Exp$]
        \label{exp2 clauses}
        Sia $Exp$ la grammatica definita all'interno dell'\cref{exp2}, e sia $E$ un suo ambiente; allora, si definiscono le seguenti regole operazionali:
        
        \begin{itemize}
            \item \tbf{costanti}: $$[const] \ \opjud{E}{k}{k}$$
            \item \tbf{variabili}: $$\forall x \in \mathrm{Var} \quad \exists v \in \mathrm{Val} \mid E(x) = v \implies [vars] \ \opjud{E}{x}{v}$$
            \item \tbf{somme}: \centeredeq{0.9}{$\forall v', v'' \in \mathrm{Val}, M, N \in Exp \quad \exists v \in \mathrm{Val} \mid v = v' + v'' \implies [plus] \ \dfrac{\opjud{E}{M}{v'} \quad \opjud{E}{N}{v''}}{\opjud{E}{M \ \ttt + \ N}{v}}$}
            \item \tbf{prodotti}: \centeredeq{0.9}{$\forall v', v'' \in \mathrm{Val}, M, N \in Exp \quad \exists v \in \mathrm{Val} \mid v = v' \cdot v'' \implies [times] \ \dfrac{\opjud{E}{M}{v'} \quad \opjud{E}{N}{v''}}{\opjud{E}{M \ \ttt * \ N}{v}}$}
            \item \tbf{dichiarazioni ed assegnazioni}: $$\forall v, v' \in \mathrm{Val}, x \in \mathrm{Var}, M, N \in Exp \quad [let] \ \dfrac{\opjud{E}{M}{v'} \quad \opjud{E\{(x, v')\}}{N}{v}}{\opjud{E}{\letin{x}{M}{N}}{v}}$$
        \end{itemize}
    \end{example}

    \begin{frameddefn}{Equivalenza operazionale}
        Sia $G$ una grammatica, e siano $M$ ed $N$ due sue espressioni; queste sono dette \tbf{operazionalmente equivalenti}, se è vera la seguente proposizione: $$\forall E \in \mathrm{Env}, v \in \mathrm{Val} \quad \opjud{E}{M}{v} \iff \opjud{E}{N}{v}$$ e viene indicato con $M \sim N$.
    \end{frameddefn}

    \begin{frameddefn}{Albero di valutazione}
        Con \tbf{albero di valutazione} di un'espressione $e$, si definisce l'albero, composto da inferenze logiche, ottenuto dalla valutazione di $e$.
    \end{frameddefn}

    \begin{framedobs}{Ambiente iniziale}
        Per qualsiasi grammatica --- a meno di specifiche --- si assume che, all'interno di una valutazione, l'ambiente iniziale sia $\varnothing \in \mathrm{Env}$.
    \end{framedobs}

    \begin{example}[Alberi di valutazione su $Exp$]
        Sia $Exp$ la grammatica definita all'interno dell'\cref{exp2}; allora, l'albero di valutazione dell'espressione $$\letin{x}{3}{x + 4}$$ è il seguente $$\dfrac{\opjud{\varnothing}{3}{3} \quad \dfrac{\opjud{\{(x, 3)\}}{x}{3} \quad \opjud{\{(x,3)\}}{4}{4}}{\opjud{\{(x, 3)\}}{x +4}{7}}}{\opjud{\varnothing}{\letin{x}{3}{x +4}}{7}}$$ e l'espressione è valutabile poiché $x \in \dom(\{(x,1)\}) = \{x\}$.
    \end{example}

    \section{Valutazioni e scoping}

    \subsection{Definizioni}

    \begin{frameddefn}{Valutazione eager}
        Data una grammatica, la \tbf{valutazione eager} valuta una data espressione della grammatica non appena questa viene legata ad una variabile. In simboli, la valutazione eager verrà indicata con il pedice $\mathrm{E}$.
    \end{frameddefn}

    \begin{frameddefn}{Valutazione lazy}
        Data una grammatica, la \tbf{valutazione lazy} valuta una data espressione della grammatica solo quando il suo valore viene richiesto da un'altra espressione. In simboli, la valutazione lazy verrà indicata con il pedice $\mathrm{L}$.
    \end{frameddefn}

    \begin{frameddefn}{Scoping statico}
        Data una grammatica, la valutazione a \tbf{scoping statico} (\tit{lexical scope}) valuta le variabili TODO. In simboli, lo scoping statico verrà indicato con il pedice $\mathrm{S}$.
    \end{frameddefn}

    \begin{frameddefn}{Scoping dinamico}
        Data una grammatica, la valutazione a \tbf{scoping dinamico} valuta le variabili utilizzando l'ambiente definito in tempo di valutazione. TODO NON MI PIACE CAMBIA. In simboli, lo scoping dinamico verrà indicato con il pedice $\mathrm{D}$.
    \end{frameddefn}

    \begin{frameddefn}[label={equiv lang}]{Equivalenza di semantiche operazionali}
        Data una grammatica, due sue semantiche operazionali sono dette \tbf{equivalenti} se, presa una qualunque espressione di $G$, quando questa viene valutata attraverso le due semantiche, produce lo stesso risultato.

        In simboli, data una grammatica $G$, e due sue semantiche operazionali $\mathrm{A}$ e $\mathrm{B}$, se queste sono equivalenti, la loro equivalenza viene denotata con il seguente simbolismo: $$G_\mathrm{A} \equiv G_\mathrm{B}$$
    \end{frameddefn}

    \begin{framedlem}{$Exp_\mathrm{ES}$ e $Exp_\mathrm{ED}$}
        Sia $Exp$ la grammatica definita all'interno dell'\cref{exp2}, avente le clausole definite nell'\cref{exp2 clauses}; allora, si ha che $$Exp_\mathrm{ES} \equiv Exp_\mathrm{ED}$$
    \end{framedlem}

    \begin{proof}
        Omessa.
    \end{proof}

    \begin{example}[$Exp_\mathrm{E}$]
        \label{eager2}
        Sia $Exp$ la grammatica definita nell'\cref{exp2}, e si consideri la seguente espressione: $$\letin{x}{3}{(\letin{y}{x}{(\letin{x}{7}{y + x})})}$$ essa, valutata attraverso valutazione eager, produce il seguente albero di derivazione: \centeredeq{0.99}{$\dfrac{\opjud{\varnothing}{3}{3} \quad \dfrac{\opjud{\{(x, 3)\}}{x}{3} \quad \dfrac{\opjud{\{(x,3),(y,3)\}}{7}{7} \quad \dfrac{\opjud{\{(x,3),(y,3)\}\{(x,7)\}}{y}{3} \quad \opjud{\{(x,3),(y,3)\}\{(x,7)\}}{x}{7}}{\opjud{\{(x,3),(y,3)\}\{(x,7)\}}{y+x}{10}}}{\opjud{\{(x, 3),(y, 3)\}}{\letin{x}{7}{y + x}}{10}}}{\opjud{\{(x, 3)\}}{\letin{y}{x}{(\letin{x}{7}{y + x})}}{10}}}{\opjud{\varnothing}{\letin{x}{3}{(\letin{y}{x}{(\letin{x}{7}{y + x})})}}{10}}$}
    \end{example}

    \begin{framedobs}{$Exp_\mathrm{LD}$}
        Sia $Exp$ la grammatica definita nell'\cref{exp2}; per poter valutare le sue espressioni in maniera lazy dinamica, è necessario ridefinire alcune regole di inferenza definite all'interno dell'\cref{exp2 clauses}:

        \begin{itemize}
            \item l'insieme degli ambienti di $Exp$ viene ridefinito come segue: $$\mathrm{Env} := \{f \mid \mathrm{Var} \xrightarrow{fin} \mathrm{Val} \cup Exp\}$$ dunque gli ambienti possono associare delle variabili anche a delle espressioni, in modo da poter ritardare la valutazione di quest'ultime fin quando non diventa strettamente necessario conoscerne il valore;
            \item $\forall E \in \mathrm{Env}, x \in \mathrm{Var} \quad x \in \dom(E) \land M := E(x) \implies \dfrac{\opjud{E}{M}{v}}{\opjud{E}{x}{v}}$, per rendere $M$ calcolabile, attraverso l'ambiente corrente, nel momento in cui viene assegnata ad una variabile;
            \item $\forall x \in \mathrm{Var}, M, N \in Exp \quad [let] \ \dfrac{\opjud{E\{(x, M)\}}{N}{v}}{\opjud{E}{\letin{x}{M}{N}}{v}}$, in modo da ritardare la valutazione di $M$.
        \end{itemize}

        Si noti che tale valutazione utilizza lo scoping dinamico, poiché viene utilizzato l'ambiente corrente per valutare le variabili.
    \end{framedobs}

    \begin{framedobs}{$Exp_\mathrm{LS}$}
        Sia $Exp$ la grammatica definita all'interno dell'\cref{exp2}; per poter valutare le sue espressioni in maniera lazy statica, è necessario ridefinire alcune regole di inferenza definite all'interno dell'\cref{exp2 clauses}:

        \begin{itemize}
            \item l'insieme degli ambienti di $Exp$ viene ridefinito come segue: $$\mathrm{Env} := \{f \mid \mathrm{Var} \xrightarrow{fin} Exp \times \mathrm{Env} \}$$ dunque gli ambienti possono associare delle variabili anche a delle tuple contenenti espressioni ed ambienti; in particolare, per una tupla $(x, (M, E))$, si ha che $x$ vale $M$ valutata nell'ambiente $E$; questa correzione nella definizione di $\mathrm{Env}$ permette di tenere traccia degli ambienti in cui sono state fatte le assegnazioni;
            \item $\forall E \in \mathrm{Env}, x \in \mathrm{Var} \quad x \in \dom(E) \land (M, E') := E(x) \implies \dfrac{\opjud{E'}{M}{v}}{\opjud{E}{x}{v}}$, affinché sia possibile valutare le variabili esattamente nell'ambiente in cui gli è stata assegnata l'espressione $M$, e non nell'ambiente corrente;
            \item $\forall x \in \mathrm{Var}, M, N \in Exp \quad [let] \ \dfrac{\opjud{E\{(x, (M, E))\}}{N}{v}}{\opjud{E}{\letin{x}{M}{N}}{v}}$, in modo da salvare anche l'ambiente in cui alla variabile $x$ è stata assegnata l'espressione $M$.
        \end{itemize}

        Si noti che tale valutazione utilizza lo scoping statico, poiché vengono salvati anche gli ambienti in cui sono state fatte le assegnazioni.
    \end{framedobs}

    \begin{framedlem}{$Exp_\mathrm{LS}$ e $Exp_\mathrm{LD}$}
        Sia $Exp$ la grammatica definita nell'\cref{exp2}; allora, si ha che $$Exp_\mathrm{LS} \not\equiv Exp_\mathrm{LD}$$
    \end{framedlem}

    \begin{proof}
        Si consideri l'espressione definita nell'\cref{eager2}; essa, valutata attraverso valutazione lazy dinamica, produce il seguente albero di derivazione: $$\dfrac{\dfrac{\dfrac{\dfrac{\dfrac{\dfrac{\opjud{\{(x,3),(y,x)\}\{(x,7)\}}{7}{7}}{\opjud{\{(x,3),(y,x)\}\{(x,7)\}}{x}{7}}}{\opjud{\{(x,3),(y,x)\}\{(x,7)\}}{y}{7}} \quad \dfrac{\opjud{\{(x,3),(y,x)\}\{(x,7)\}}{7}{7}}{\opjud{\{(x,3),(y,x)\}\{(x,7)\}}{x}{7}}}{\opjud{\{(x,3),(y,x)\}\{(x,7)\}}{y+x}{14}}}{\opjud{\{(x,3),(y,x)\}}{\letin{x}{7}{y+x}}{14}}}{\opjud{\{(x,3)\}}{\letin{y}{x}{(\letin{x}{7}{y+x})}}{14}}}{\opjud{\varnothing}{\letin{x}{3}{(\letin{y}{x}{(\letin{x}{7}{y+x})})}}{14}}$$

        Differentemente, valutando tale espressione attraverso valutazione lazy statica, produce il seguente albero di derivazione: $$\dfrac{\dfrac{\dfrac{\dfrac{\dfrac{\dfrac{\opjud{\varnothing}{3}{3}}{\opjud{E}{x}{3}}}{\opjud{E''}{y}{3}} \quad \dfrac{\opjud{E'}{7}{7}}{\opjud{E''}{x}{7}}}{\opjud{E'\{(x,(7,E'))\}}{y+x}{10}}}{\opjud{E\{(y,(x, E))\}}{\letin{x}{7}{y+x}}{10}}}{\opjud{\{(x,(3,\varnothing))\}}{\letin{y}{x}{(\letin{x}{7}{y+x})}}{10}}}{\opjud{\varnothing}{\letin{x}{3}{(\letin{y}{x}{(\letin{x}{7}{y+x})})}}{10}}$$ dove $$\centeredsoe{E := \{(x,(3,\varnothing))\} \\ E' := E\{(y,(x,E))\} \\ E'' := E'\{(x,(7,E'))\}}$$

        Allora, poiché le due valutazioni producono risultati differenti, per la \cref{equiv lang}, segue la tesi.
    \end{proof}

    \section{Funzioni}

    \subsection{Definizioni}

    \begin{frameddefn}[label={fn}]{Clausola $fn$}
        Sia $G$ una grammatica; allora, è possibile definire su $G$ una funzione $fn$, come segue: $$\func{fn}{\mathrm{Var} \times G}{G}$$ e verrà utilizzata attraverso la sintassi $$\fn{\ttt{*variable*}}{\ttt{\_expression\_}}$$ che restituisce una funzione avente come parametro $\ttt{*variable*}$, il cui valore sarà utilizzato per valutare $\ttt{\_expression\_}$.
    \end{frameddefn}

    \begin{frameddefn}{Applicazione}
        Sia $G$ una grammatica; allora, dati due suoi termini $M,N$, è possibile definire su $G$ l'applicazione di $M$ ad $N$, attraverso la seguente sintassi: $$MN$$ Tale sintassi è presa in prestito dal lambda calcolo.

        Si noti che un'espressione $MNL$ applica prima $M$ ad $N$, e poi $MN$ ad $L$, dunque la precedenza è da sinistra verso destra, ovvero $(MN)L$.
    \end{frameddefn}

    \begin{example}[Grammatica $Fun$]
        \label{fun}
        Sia $Fun$ la seguente estensione della grammatica $Exp$, definita all'interno dell'\cref{exp2}: $$M,N ::= k \ | \ x \ | \ M \ \ttt + \ N \ | \ M \ \ttt * \ N \ | \ \letin{x}{M}{N} \ | \ \fn{x}{M} \ | \ MN$$
    \end{example}

    \begin{example}[Espressioni su $Fun$]
        Sia $Fun$ la grammatica definita all'interno dell'\cref{fun}, e sia $$(\fn{x}{x +1})7$$ una sua espressione; essa, poiché applica la funzione $\fn{x}{x+1}$ all'espressione 7, viene valutata a $$x = 7 \implies x + 1= 7 + 1 = 8$$
    \end{example}

    \begin{example}[Espressioni su $Fun$]
        \label{expr fun}
        Sia $Fun$ la grammatica definita all'interno dell'\cref{fun}, e sia $$(\fn{x}{x3})(\fn{x}{x+1})$$ una sua espressione; essa, una volta valutata, applica la funzione $\fn{x}{x+1}$ all'espressione 3, e dunque il suo valore è pari a $$x = 3 \implies x + 1 = 3 + 1 = 4$$
    \end{example}

    \begin{framedobs}{Curryficazione}
        Si consideri la clausola $fn$ della \cref{fn}; è possibile definirne una notazione contratta, che prende il nome di \tit{curryficazione}, ed è definita come segue: $$\fn{x_1x_2 \ldots x_n}{M} \iff \fn{x_1}{(\fn{x_2}{\ldots (\fn{x_n}{M}) \ldots})}$$ Il processo inverso prende il nome di \tit{uncurryficazione}.
    \end{framedobs}

    \begin{example}[Curryficazioni]
        Sia $Fun$ la grammatica dell'\cref{fun}, e sia $$(\fn{xy}{yx})7(\fn{x}{x+1})$$ una sua espressione; una volta effettuata l'uncurryficazione, si ottiene la seguente espressione: $$(\fn{x}{\fn{y}{yx}})7(\fn{x}{x+1})$$ che, una volta valutata, diventa $$(\fn{y}{y7})(\fn{x}{x+1})$$ e dunque, analogamente all'\cref{expr fun}, il risultato è $$x= 7 \implies x+1 = 7 + 1= 8$$
    \end{example}

    \begin{example}[Curryficazioni]
        Sia $Fun$ la grammatica dell'\cref{fun}, e sia $$(\fn{x}{xx})(\fn{x}{xx})$$ una sua espressione; essa, durante la valutazione, va in loop infinito, poiché ad ogni valutazione viene restituita l'espressione di partenza.
    \end{example}

    \subsection{Semantiche operazionali}

    \begin{framedobs}{$Fun_\mathrm{ED}$}
        Sia $Fun$ la grammatica definita nell'\cref{fun}; per poter valutare le sue espressioni in maniera eager dinamica, è necessario ridefinire alcune regole di inferenza:

        \begin{itemize}
            \item l'insieme degli ambienti di $Fun$ viene definito come segue: $$\mathrm{Env} := \{f \mid f : \mathrm{Var} \xrightarrow{fin} \mathrm{Val}\}$$
            \item l'insieme dei valori di $Fun$ viene ridefinito come segue: $$\mathrm{Val} := \{ \ttt 0, \ttt 1 , \ldots \} \cup (\mathrm{Var} \times Fun)$$ affinché i giudizi operazionali di $Fun$ possano contenere tuple;
            \item $\forall E \in \mathrm{Env}, x \in \mathrm{Var}, M \in Fun \quad \opjud{E}{\fn{x}{M}}{(x,M)}$ per la valutazione delle funzioni;
            \item $\forall E \in \mathrm{Env}, M,N \in Fun \quad \dfrac{\opjud{E}{M}{(x,L)} \quad \opjud{E}{N}{v'} \quad \opjud{E\{(x,v')\}}{L}{v}}{\opjud{E}{MN}{v}}$ per certi $x \in \mathrm{Var}, L \in Fun$ tali che $M$ sia una funzione della forma $\fn{x}{L}$; dunque, per le applicazioni, si ha che il primo giudizio operazionale forza $M$ ad essere una funzione, il secondo valuta $N$, ed il terzo valuta $L$ con $x$ pari al valore di $N$.
        \end{itemize}

        Si noti che tale valutazione risulta essere eager, poiché $N$ viene valutata immediatamente.
    \end{framedobs}

    \begin{framedobs}{$Fun_\mathrm{ES}$}
        Sia $Fun$ la grammatica definita nell'\cref{fun}; per poter valutare le sue espressioni in maniera eager statica, è necessario ridefinire alcune regole di inferenza:

        \begin{itemize}
            \item l'insieme degli ambienti di $Fun$ viene definito come segue: $$\mathrm{Env} := \{f \mid f : \mathrm{Var} \xrightarrow{fin} \mathrm{Val}\}$$
            \item l'insieme dei valori di $Fun$ viene ridefinito come segue: $$\mathrm{Val} := \{ \ttt 0, \ttt 1, \ldots \} \cup (\mathrm{Var} \times Fun \times \mathrm{Env})$$ affinché i giudizi operazionali di $Fun$ possano contenere triple;
            \item $\forall E \in \mathrm{Env}, x \in \mathrm{Var}, M \in Fun \quad \opjud{E}{\fn{x}{M}}{(x,M,E)}$ per la valutazione delle funzioni;
            \item \resizable{0.94}{$\forall E \in \mathrm{Env}, M,N \in Fun \quad \dfrac{\opjud{E}{M}{(x,L,E')} \quad \opjud{E}{N}{v'} \quad \opjud{E'\{(x,v')\}}{L}{v}}{\opjud{E}{MN}{v}}$} per certi $E' \in \mathrm{Env}, x \in \mathrm{Var}, L \in Fun$ tali che $M$ sia una funzione della forma $\fn{x}{L}$; dunque, per le applicazioni, si ha che il primo giudizio operazionale forza $M$ ad essere una funzione --- salvando inoltre l'ambiente in cui la funzione $M$ è stata valutata --- il secondo valuta $N$, ed il terzo valuta $L$ con $x$ pari al valore di $N$, ma all'interno dell'ambiente che era stato salvato valutando la funzione $M$.
        \end{itemize}

        Si noti che tale valutazione risulta essere eager, poiché $N$ viene valutata immediatamente, ed è a scoping statico poiché viene riportato l'ambiente in cui le valutazioni vengono effettuate.
    \end{framedobs}

    \begin{framedlem}[label={fun lemma pt1}]{$Fun_\mathrm{ES}$ e $Fun_\mathrm{ED}$}
        Sia $Fun$ la grammatica definita nell'\cref{fun}; allora, si ha che $$Fun_\mathrm{ES} \not\equiv Fun_\mathrm{ED}$$
    \end{framedlem}

    \begin{proof}
        Si consideri la seguente espressione $$\letin{x}{7}{((\fn{y}{\letin{x}{3}{yx}})(\fn{z}{x}))}$$ definita sulla grammatica $Fun$; essa, valutata attraverso valutazione eager dinamica, produce il seguente albero di derivazione: $$(*) \quad \dfrac{\opjud{E'}{3}{3} \quad \dfrac{\opjud{E''}{y}{(z,x)} \quad \opjud{E''}{x}{3} \quad \opjud{E''\{(z,3)\}}{x}{3}}{\opjud{E'\{(x,3)\}}{yx}{3}}}{\opjud{E\{(y,(z,x))\}}{\letin{x}{3}{yx}}{3}}$$ \centeredeq{0.99}{$\dfrac{\opjud{\varnothing}{7}{7} \quad \dfrac{\opjud{E}{\fn{y}{\letin{x}{3}{yx}}}{(y, \letin{x}{3}{yx})} \quad \opjud{E}{\fn{z}{x}}{(z,x)} \quad (*)}{\opjud{\{(x,7)\}}{((\fn{y}{\letin{x}{3}{yx}})(\fn{z}{x}))}{3}}}{\opjud{\varnothing}{\letin{x}{7}{((\fn{y}{\letin{x}{3}{yx}})(\fn{z}{x}))}}{3}}$}

        dove $$\centeredsoe{E := \{(x,7)\} \\ E' := E\{(y,(z,x))\} \\ E'' := E'\{(x,3)\}}$$

        Differentemente, valutando tale espressione attraverso valutazione eager statica, produce il seguente albero di derivazione: $$(*) \quad \dfrac{\opjud{E'}{3}{3} \quad \dfrac{\opjud{E''}{y}{(z,x,E)} \quad \opjud{E''}{x}{3} \quad \opjud{E\{(z,3)\}}{x}{7}}{\opjud{E'\{(x,3)\}}{yx}{7}}}{\opjud{E\{(y,(z,x,E))\}}{\letin{x}{3}{yx}}{7}}$$ \centeredeq{0.99}{$\dfrac{\opjud{\varnothing}{7}{7} \quad \dfrac{\opjud{E}{\fn{y}{\letin{x}{3}{yx}}}{((y,\letin{x}{3}{yx}),E)} \quad \opjud{E}{\fn{z}{x}}{(z,x,E)} \quad (*)}{\opjud{\{(x,7)\}}{(\fn{y}{\letin{x}{3}{yx}})(\fn{z}{x})}{7}}}{\opjud{\varnothing}{\letin{x}{7}{((\fn{y}{\letin{x}{3}{yx}})(\fn{z}{x}))}}{7}}$} dove $$\centeredsoe{E: =\{(x,7)\} \\ E' := E\{(y,(z,x,E))\} \\ E'' := E'\{(x,3)\}}$$

        Allora, poiché le due valutazioni producono risultati differenti, per la \cref{equiv lang}, segue la tesi.
    \end{proof}

    \begin{framedobs}{$Fun_\mathrm{LD}$}
        Sia $Fun$ la grammatica definita nell'\cref{fun}; per poter valutare le sue espressioni in maniera lazy dinamica, è necessario ridefinire alcune regole di inferenza:

        \begin{itemize}
            \item l'insieme degli ambienti di $Fun$ viene ridefinito come segue: $$\mathrm{Env} := \{ f \mid f: \mathrm{Var} \xrightarrow{fin} Fun \}$$
            \item l'insieme dei valori di $Fun$ viene ridefinito come segue: $$\mathrm{Val} := \{ \ttt 0, \ttt 1, \ldots \} \cup (\mathrm{Var} \times Fun)$$ affinché i giudizi operazionali di $Fun$ possano contenere tuple;
            \item $\forall E \in \mathrm{Env}, x \in \mathrm{Var}, M \in Fun \quad \opjud{E}{\fn{x}{M}}{(x,M)}$ per la valutazione delle funzioni;
            \item $\forall E \in \mathrm{Env}, M,N \in Fun \quad \dfrac{\opjud{E}{M}{(x,L)} \quad \opjud{E'\{(x,N)\}}{L}{v}}{\opjud{E}{MN}{v}}$ per certi $x \in \mathrm{Var}, L \in Fun$ tali che $M$ sia una funzione della forma $\fn{x}{L}$; dunque, per le applicazioni, si ha che il primo giudizio operazionale forza $M$ ad essere una funzione, mentre il secondo valuta $L$ con $x$ pari ad $N$ --- e non al valore che questa assume.
        \end{itemize}

        Si noti che tale valutazione risulta essere lazy, poiché $N$ non viene valutata immediatamente, ma ne viene ritardato il calcolo finché non strettamente necessario.
    \end{framedobs}

    \begin{framedobs}{$Fun_\mathrm{LS}$}
        Sia $Fun$ la grammatica definita nell'\cref{fun}; per poter valutare le sue espressioni in maniera lazy statica, è necessario ridefinire alcune regole di inferenza:

        \begin{itemize}
            \item l'insieme degli ambienti di $Fun$ viene ridefinito come segue: $$\mathrm{Env} := \{f \mid f :\mathrm{Var} \xrightarrow{fin} Fun \times \mathrm{Env}\}$$ dunque, la sua definizione è ricorsiva
            \item l'insieme dei valori di $Fun$ viene ridefinito come segue: $$\mathrm{Val} := \{\ttt 0, \ttt 1, \ldots\} \cup (\mathrm{Var} \times Fun \times \mathrm{Env})$$
            \item $\forall E \in \mathrm{Env}, x \in \mathrm{Var}, M \in Fun \quad \opjud{E}{\fn{x}{M}}{(x,M,E)}$ per la valutazione delle funzioni;
            \item $\forall E \in \mathrm{Env}, M,N \in Fun \quad \dfrac{\opjud{E}{M}{(x,L,E')} \quad \opjud{E'\{(x,(N,E))\}}{L}{v}}{\opjud{E}{MN}{v}}$ per certi $E' \in \mathrm{Env}, x \in \mathrm{Var}, L \in Fun$ tali che $M$ sia una funzione della forma $\fn{x}{L}$; dunque, per le applicazioni, si ha che il primo giudizio operazionale forza $M$ ad essere una funzione --- salvando inoltre l'ambiente in cui la funzione $M$ è stata valutata --- mentre il secondo valuta $L$ senza valutare l'espressione $N$, ma ponendo solamente $x$ pari ad $N$ -- e non al suo valore --- all'interno dell'ambiente in cui è stata effettuata l'applicazione $MN$.
        \end{itemize}

        Si noti che tale valutazione risulta essere lazy, poiché $N$ non viene valutata immediatamente, ed è a scoping statico poiché viene riportato l'ambiente in cui le valutazioni vengono effettuate.
    \end{framedobs}

    \begin{framedlem}[label={fun lemma pt2}]{$Fun_\mathrm{LS}$ e $Fun_\mathrm{LD}$}
        Sia $Fun$ la grammatica definita nell'\cref{fun}; allora, si ha che $$Fun_\mathrm{LS} \not\equiv Fun_\mathrm{LD}$$
    \end{framedlem}

    \begin{proof}
        Omessa.
    \end{proof}

    \begin{frameddefn}{Espressione $\omega$}
        Data una grammatica, l'\tbf{espressione $\omega$} è un'espressione composta dalla più piccola funzione che entra in ricorsione infinita senza chiamare sé stessa.
    \end{frameddefn}

    \begin{example}[Espressione $\omega$ di $Fun$]
        \label{omega fun}
        Sia $Fun$ la grammatica definita all'interno dell'\cref{fun}; allora, una sua espressione $\omega$ è la seguente: $$\omega := (\fn{x}{xx})(\fn{x}{xx})$$ Essa risulta essere un'espressione $\omega$ per $Fun$, poiché la sua valutazione entra in ricorsione infinita indipendentemente dalla semantica scelta.
    \end{example}

    \begin{framedlem}{Semantiche di $Fun$}
        Sia $Fun$ la grammatica definita nell'\cref{fun}; allora, si ha che $$Fun_\mathrm{LD} \not\equiv Fun_\mathrm{ED} \not\equiv Fun_\mathrm{ES} \not\equiv Fun_\mathrm{LS}$$
    \end{framedlem}
    
    \begin{proof}
        Si noti che:

        \begin{itemize}
            \item $Fun_\mathrm{ED} \not\equiv Fun_\mathrm{ES}$ per il \cref{fun lemma pt1}
            \item $Fun_\mathrm{LS} \not\equiv Fun_\mathrm{LD}$ per il \cref{fun lemma pt2}
        \end{itemize}

        mentre, per quanto riguarda $Fun_\mathrm{ED} \not\equiv Fun_\mathrm{LD}$ e $Fun_\mathrm{ES} \not\equiv Fun_\mathrm{LS}$, si prenda l'espressione $\omega$ di $Fun$, presentata all'interno dell'\cref{omega fun}, e si consideri la seguente espressione $$\letin{x}{\omega}{69} \footnote{Nice.}$$ questa, quando valutata in maniera eager --- indipendentemente dallo scoping --- richiederebbe di valutare immediatamente l'espressione $\omega$, la quale è invalutabile per definizione; mentre, quando valutata in maniera lazy --- indipendentemente dallo scoping --- rimanderebbe il calcolo dell'espressione $\omega$, restituendo 69 come risultato. Dunque, poiché si ottengono risultati diversi a seconda della semantica utilizzata per valutare tale espressione, segue la tesi.
    \end{proof}

    \begin{framedobs}{Variabili libere di $Fun$}
        Sia $Fun$ la grammatica dell'\cref{fun}; su di essa, è possibile definire, ricorsivamente, una funzione in grado di restituire le variabili free di una data espressione, come segue: \centeredeq{0.99}{$\funcmap{\mathrm{free}}{Fun}{\powerset{\left(\mathrm{Var}\right)}}{e}{\soe{ll}{
            \varnothing & \exists \eta \in \N \mid e = k(\eta) \\ 
            \{x\} & \exists x \in \mathrm{Var} \mid e = x \\ 
            \mathrm{free}(M) \cup \mathrm{free}(N) & \exists M, N \in Fun \mid e = M \ \ttt + \ N \lor e = M \ \ttt * \ N \\
            \mathrm{free}(M) \cup (\mathrm{free}(N) - \{x\}) & \exists x \in \mathrm{Var}, M, N \in Fun \mid e = (\letin{x}{M}{N}) \\
            \mathrm{free}(M) - \{x\} & \exists x \in \mathrm{Var} , M \in Fun \mid e = (\fn{x}{M}) \\
            \mathrm{free}(M) \cup \mathrm{free}(N) & \exists M,N \in Fun \mid e = (MN)
        }}$}
    \end{framedobs}

    \section{Lambda calcolo}

    \subsection{Numeri di Church}

    \begin{frameddefn}{Numeri di Church}
        La \tbf{rappresentazione di Church} dei numeri naturali, denotata con $\N_\lambda$, è la seguente:
        \begin{itemize}
            \item $0_\lambda := \fn{x}{\fn{y}{y}} \iff \fn{xy}{y}$
            \item $\mathrm{succ}_\lambda := \fn{z}{(\fn{x}{\fn{y}{z x (x y)})}} \iff \fn{zxy}{zx(xy)}$
        \end{itemize}
    \end{frameddefn}

    \begin{example}[$1_\lambda$ di Church]
        \label{1 church}
        Per calcolare l'$1_\lambda \in \N_\lambda$ di Church, è sufficiente valutare $\mathrm{succ}_\lambda(0_\lambda)$, e dunque $$\centeredsoe{(\fn{zxy}{zx(xy)})(\fn{xy}{y}) \longrightarrow \fn{xy}{(\fn{xy}{y})x(xy)} \longrightarrow \\ \longrightarrow \fn{xy}{(\fn{y}{y})(xy)} \longrightarrow \fn{xy}{xy} =: 1_\lambda}$$
    \end{example}

    \begin{example}[$2_\lambda$ di Church]
        \label{2 church}
        Per calcolare il $2_\lambda \in \N_\lambda$ di Church, è sufficiente valutare $\mathrm{succ}_\lambda(1_\lambda)$, e dunque $$\centeredsoe{(\fn{zxy}{zx(xy)})(\fn{xy}{xy}) \longrightarrow \fn{xy}{(\fn{xy}{xy})x(xy)} \longrightarrow \\ \longrightarrow \fn{xy}{(\fn{y}{xy})(xy)} \longrightarrow \fn{xy}{xxy} =: 2_\lambda}$$
    \end{example}

    \begin{framedprop}{Algebra dei numeri di Church}
        Si consideri l'algebra dei numeri di Church, definita come $(\N_\lambda, \mathrm{zero}_\lambda, \mathrm{succ}_\lambda)$, dove $$\funcmap{\mathrm{zero}_\lambda}{\1}{\N_\lambda}{x}{0_\lambda}$$ Essa è un'algebra induttiva.
    \end{framedprop}

    \begin{proof}
        Omessa.
    \end{proof}

    \begin{framedobs}{Significato di $\N_\lambda$}
        Si considerino l'\cref{1 church} e l'\cref{2 church}, e si noti che $$\centeredsoe{0_\lambda := \fn{xy}{y} \\ 1_\lambda := \fn{xy}{xy} \\ 2_\lambda :=\fn{xy}{x(xy)} \\ \vdots}$$ dunque, la corrispondenza tra $\N$ e $\N_\lambda$ è data dal \tit{numero di applicazioni effettuate} ad una qualche variabile. Infatti è possibile costruire il seguente isomorfismo tra le algebre $(\N, \mathrm{zero}, \mathrm{succ})$ e $(\N_\lambda, \mathrm{zero}_\lambda, \mathrm{succ}_\lambda)$: $$\funcmap{\varphi}{\N}{\N_\lambda}{n}{\fn{xy}{\underbrace{x \cdots (x}_{n \ \mathrm{volte}}y)}}$$ dove $x$ è dunque una funzione, che può essere applicata ad una certa variabile $y$.
    \end{framedobs}

    \begin{framedobs}{Funzione $\mathrm{eval}_\lambda$}
        È possibile definire una funzione che, dato un numero di Church, restituisce il corrispondente numero naturale, come segue: $$\mathrm{eval}_\lambda := \fn{z}{z (\fn{x}{x+1}) 0}$$ poiché applica la funzione $\mathrm{succ}_{\N}$ esattamente $z \in \N_\lambda$ volte a 0.
    \end{framedobs}

    \begin{example}[Corrispondenze tra $\N_\lambda$ e $\N$]
        Per valutare $\mathrm{eval}_\lambda(1_\lambda)$ è necessario svolgere i seguenti calcoli: $$\centeredsoe{(\fn{z}{z (\fn{x}{x+1})0})(\fn{xy}{xy}) \longrightarrow (\fn{xy}{xy})(\fn{x}{x+1})0 \longrightarrow \\ \longrightarrow (\fn{y}{(\fn{x}{x+1})y})0 \longrightarrow (\fn{x}{x+1})0 \longrightarrow 1}$$
    \end{example}

    \begin{framedobs}{Operazione $\mathrm{sum}_\lambda$}
        Si consideri l'algebra dei numeri di Church; su di essa, è possibile definire l'operazione di somma, come segue: $$\mathrm{sum}_\lambda := \fn{z}{\fn{w}{(\fn{x}{\fn{y}{z x (w x y)}})}} \iff \fn{zwxy}{zx(wxy)}$$ poiché alla variabile $y$ viene prima applicata $x$ esattamente $w \in \N_\lambda$ volte ad $y$, e successivamente ad esso viene applicata $x$ altre $z \in \N_\lambda$ volte. Inoltre, è possibile fornire una definizione altenrativa della funzione, come segue: $$\mathrm{sum}_\lambda := \fn{z}{\fn{w}{z \ \mathrm{succ}_\lambda \ w}} \iff \fn{zw}{z \ \mathrm{succ}_\lambda \ w}$$ poiché viene applicata la funzione di successore $\mathrm{succ}_\lambda$ a $w \in \N_\lambda$, esattamente $z \in \N_\lambda$ volte.
    \end{framedobs}

    \begin{example}[Somme in $\N_\lambda$]
        Per calcolare $\mathrm{sum}_\lambda(2_\lambda, 1_\lambda)$ è necessario svolgere i seguenti calcoli: $$\centeredsoe{(\fn{zwxy}{zx(wxy)})(\fn{xy}{x(xy)})(\fn{xy}{xy}) \longrightarrow \\ \longrightarrow (\fn{wxy}{(\fn{xy}{x(xy)})x(wxy)})(\fn{xy}{xy}) \longrightarrow \\ \longrightarrow (\fn{wxy}{(\fn{y}{x(xy)})(wxy)})(\fn{xy}{xy}) \longrightarrow \\ \longrightarrow (\fn{wxy}{x(x(wxy))})(\fn{xy}{xy}) \longrightarrow \fn{xy}{x(x((\fn{xy}{xy})xy))} \longrightarrow \\ \longrightarrow \fn{xy}{x(x((\fn{y}{xy})y))} \longrightarrow \fn{xy}{x(x(xy))} =: 3_\lambda}$$
    \end{example}

    \begin{framedobs}{Operazione $\mathrm{prod}_\lambda$}
        Si consideri l'algebra dei numeri di Church; su di essa, è possibile definire l'operazione di prodotto, come segue: $$\mathrm{prod}_\lambda := \fn{z}{\fn{w}{(\fn{x}{\fn{y}{z(wx)y}})}} \iff \fn{zwxy}{z(wx)y}$$ poiché alla variabile $y$ viene applicata la funzione $z(wx)$, che equivale alla funzione $wx$ composta su sé stessa $z$ volte --- e dunque $z, w \in \N_\lambda$. Inoltre, è possibile fornire una definizione altenrativa della funzione, come segue: $$\mathrm{prod}_\lambda := \fn{z}{\fn{w}{z (\mathrm{sum}_\lambda \ w)0_\lambda}} \iff \fn{zw}{z(\mathrm{sum}_\lambda \ w)0_\lambda}$$ poiché allo $0_\lambda$ viene applicata la funzione $z(\mathrm{sum}_\lambda \ w)$, che equivale alla funzione $(\mathrm{sum}_\lambda \ w)$ --- la quale restituisce una funzione che si aspetta il secondo argomento a cui applicare la somma, che sarà $0_\lambda$ --- composta su sé stessa $z \in \N_\lambda$ volte.
    \end{framedobs}

    \begin{framedobs}{Operazione $\mathrm{power}_\lambda$}
        Si consideri l'algebra dei numeri di Church; su di essa, è possibile definire l'operazione di elevamento a potenza, come segue: $$\mathrm{power}_\lambda := \fn{z}{\fn{w}{wz}}$$ TODO.
    \end{framedobs}

    \subsection{Logica booleana di Church}

    \begin{frameddefn}{Logica booleana di Church}
        La \tbf{rappresentazione di Church} della logica booleana, denotata con $B_\lambda$, è la seguente

        \begin{itemize}
            \item $\mathrm{true}_\lambda := \fn{x}{\fn{y}{x}} \iff \fn{xy}{x}$
            \item $\mathrm{false}_\lambda := \fn{x}{\fn{y}{y}} \iff \fn{xy}{y}$
        \end{itemize}
    \end{frameddefn}

    \begin{framedobs}{Funzione $\mathrm{evalBool}_\lambda$}
        Si consideri la grammatica definita all'interno dell'\cref{fun}; è possibile estenderla affinché includa anche i valori booleani $true$ e $false$. Dunque, è possibile definire una funzione che, dato un booleano di Church, restituisce il corrispondente valore booleano, come segue: $$\mathrm{evalBool}_\lambda := \fn{z}{z \ true \ false}$$
    \end{framedobs}

    \begin{example}[Valutazione di $\mathrm{true}_\lambda$]
        Per valutare $\mathrm{evalBool}_\lambda(\mathrm{true}_\lambda)$, è sufficiente svolgere i seguenti calcoli: $$\centeredsoe{(\fn{z}{z \ true \ false})(\fn{xy}{x}) \longrightarrow (\fn{xy}{x})true \ false \longrightarrow \\ \longrightarrow (\fn{y}{true})false \longrightarrow true}$$
    \end{example}

    \begin{framedobs}[label={ite}]{Operazione $\mathrm{ite}_\lambda$}
        Si consideri l'algebra dei booleani di Church; su di essa, è possibile definire l'operazione logica \tit{if-then-else}, come segue: $$\mathrm{ite}_\lambda := \fn{z}{\fn{u}{\fn{v}{zuv}}} \iff \fn{zuv}{zuv}$$ poiché dato un $z \in B_\lambda$, la funzione restituirà $u$ se $z$ è $\mathrm{true}_\lambda$, altrimenti $v$.
    \end{framedobs}

    \begin{framedobs}{Operazione $\mathrm{if}_\lambda$}
        Si consideri l'algebra dei booleani di Church; su di essa, è possibile definire l'operazione logica \tit{if}, come segue: $$\mathrm{if}_\lambda := \fn{z}{\fn{u}{z \ u \ \mathrm{true}_\lambda}} \iff \fn{zu}{z \ u \ \mathrm{true}_\lambda}$$ poiché l'operazione è equivalente ad $\mathrm{ite}_\lambda$ definita all'interno dell'\cref{ite}, ma il branch dell'\tit{else} restituisce sempre $\mathrm{true}_\lambda$.
    \end{framedobs}

    \begin{framedobs}{Operazione $\mathrm{not}_\lambda$}
        Si consideri l'algebra dei booleani di Church; su di essa, è possibile definire l'operazione logica di negazione come segue: $$\mathrm{not}_\lambda := \fn{z}{(\fn{x}\fn{y}{zyx})} \iff \fn{zxy}{zyx}$$ poiché tale funzione passa ad un certo $z \in B_\lambda$ le variabili $x$ ed $y$ scambiate di posto. Si noti che l'operazione è simile all'operazione $\mathrm{ite}_\lambda$ definita nell'\cref{ite}, poiché è possibile interpretarla come l'inverso dell'operazione \tit{if-then-else}.
    \end{framedobs}

    \begin{framedobs}{Operazione $\mathrm{or}_\lambda$}
        Si consideri l'algebra dei booleani di Church; su di essa, è possibile definire l'operazione logica di $or$, come segue: $$\mathrm{or}_\lambda := \fn{z}{\fn{w}{\mathrm{if}_\lambda(\mathrm{not}_\lambda \ z)w}} \iff \fn{zw}{\mathrm{if}_\lambda(\mathrm{not}_\lambda \ z)w}$$ poiché TODO
    \end{framedobs}

    \begin{framedobs}{Operazione $\mathrm{and}_\lambda$}
        Si consideri l'algebra dei booleani di Church; su di essa, è possibile definire l'operazione logica di $and$, come segue: $$\mathrm{and}_\lambda := \fn{z}{\fn{w}{\mathrm{not}_\lambda(\mathrm{if}_\lambda \ z (\mathrm{not}_\lambda \ w))}}$$ poiché TODO
    \end{framedobs}

    \subsection{Lambda calcolo}

    \begin{frameddefn}{Lambda calcolo}
        Il \tbf{lambda calcolo} è un sistema formale atto ad analizzare le funzioni e le loro applicazioni. La grammatica del lambda calcolo è la seguente $$M,N ::= x \ | \ \lambda x . M \ | \ MN$$ dove $\lambda x.M$ indica una funzione della forma $\fn{x}{M}$, e prende il nome di \tbf{lambda astrazione}. Le espressioni del lambda calcolo sono dette \tbf{lambda espressioni}.
    \end{frameddefn}

    \begin{example}[Lambda espressioni]
        I seguenti sono esempi di espressioni del lambda calcolo:

        \begin{itemize}
            \item $(\lambda x.x +1)2$ corrisponde a $(\fn{x}{x+1})2$ ed equivale a 3
            \item $\lambda xy.x(x(xy))$ corrisponde a $\fn{xy}{x(x(xy))}$, ovvero $3_\lambda \in \N_\lambda$
            \item $(\lambda x.xy)(\lambda x.x)$ equivale ad $y$
        \end{itemize}
    \end{example}

    \begin{frameddefn}[label={sub}]{Sostituzione}
        Date due espressioni $M$ ed $N$, ed una variabile $x$, l'operazione di \tbf{sostituzione} rimpiazza ogni occorrenza della variabile $x$ --- all'interno dell'espressione $M$ --- con il termine $N$. In simboli $$M[N/x]$$ 
    \end{frameddefn}

    \begin{example}[Sostituzioni]
        I seguenti sono esempi di sostitutioni all'interno di espressioni:

        \begin{itemize}
            \item $(xy)[\lambda z.z/x]$ corrisponde a $(\lambda z.z)y$, ovvero $y$
            \item $(\fn{x}{y})[x/y]$ corrisponde a $\fn{x}{x}$
        \end{itemize}
    \end{example}

    \begin{framedobs}{Cattura di variabili}
        L'operazione di sostituzione, definita nella \cref{sub}, potrebbe cambiare il binding delle variabili definite; tale fenomeno prende il nome di \tbf{cattura di variabili}.
    \end{framedobs}

    \begin{example}[Catture di variabili]
        Si consideri la seguente espressione: $$(\lambda y.M)[N/x]$$ se $N$ contenesse la variabile $y$ in modo libero, si avrebbe che $$\lambda y.(M[N/x])$$ non sarebbe equivalente all'espressione di partenza, poiché $y$ diverrebbe legata. Dunque, la loro equivalenza è garantita solamente se $y \notin \mathrm{free}(N)$.
    \end{example}

    \begin{frameddefn}{Alfa conversione}
        Data una lambda astrazione $\lambda x.M$, si definisce \tbf{alfa conversione} la regola secondo la quale ogni occorrenza di $x$ nella lambda astrazione viene rimpiazzata con un altra variabile. In simboli $$\lambda x.M \alphaconv \lambda y.(M[y/x])$$
    \end{frameddefn}

    \begin{example}[Alfa conversioni]
        Si consideri la seguente lambda astrazione $$\lambda x.x(\lambda z.zw)$$ allora, ad esempio, è vero che $$\lambda x.x(\lambda z.zw) \alphaconv \lambda z.z(\lambda z.zw)$$ avendo rimpiazzato $x$ con $z$.
    \end{example}

    \begin{frameddefn}{Alfa equivalenza}
        Due lambda astrazioni $\lambda x.M$ e $\lambda y.N$ sono dette \tbf{alfa equivalenti}, indicato con il simbolo $\equiv_\alpha$ se è vera la seguente: $$\lambda x.M \equiv_\alpha \lambda .N \iff \soe{l}{\lambda x.M \alphaconv \lambda y.(N[y/x]) \\ \lambda y.N \alphaconv \lambda x.(M[x/y])}$$
    \end{frameddefn}

    \begin{example}[Alfa equivalenze]
        Si considerino le due seguenti lambda astrazioni $$\centeredsoe{\lambda x.xy \\ \lambda z.zy}$$ e si noti che $$\soe{l}{\lambda x.xy \alphaconv \lambda z.zy \\ \lambda z.zy \alphaconv \lambda x.xy} \iff \lambda x.xy \equiv_\alpha \lambda z.zy$$ dunque le due lambda astrazioni sono alfa equivalenti. Si considerino invece le due seguenti lambda astrazioni $$\centeredsoe{\lambda x.x (\lambda z.z w) \\ \lambda z.z(\lambda z.zw)}$$ e si noti, differentemente, che $$\soe{l}{\lambda x.x (\lambda z.zw) \alphaconv \lambda z.z(\lambda z.z w) \\ \lambda z.z(\lambda z.zw) \ \not\mathrel{\mkern-5mu\longrightarrow_{\alpha}} \lambda x.x(\lambda z.zw) } \implies \lambda x.x(\lambda z.zw) \not\equiv_\alpha \lambda z.z(\lambda z.zw)$$
    \end{example}

    \begin{frameddefn}{Beta conversione}
        Data una lambda espressione $(\lambda x.M)$, si definisce \tbf{beta conversione} la regola secondo la quale ogni occorrenza di $x$ all'interno di $M$ viene rimpiazzata dal termine $N$. In simboli $$(\lambda x.M)N \betaconv M[N/x]$$ Di fatto, la beta conversione corrisponde ad un passo computazionale.
    \end{frameddefn}

    \begin{example}[Beta conversioni]
        Si consideri la seguente lambda espressione $$(\lambda x.xy)(\lambda z.z)$$ applicando la beta conversione, si ottiene $$(\lambda x.xy)(\lambda z.z) \betaconv (\lambda z.z)y \betaconv y$$
    \end{example}

    \begin{frameddefn}[label={eta conv}]{Eta conversione}
        Si definisce \tbf{eta conversione} la regola secondo la quale una lambda espressione $(\lambda x.Mx)$ può essere rimpiazzata con $M$, solo se $x$ non è libera. In simboli $$x \notin \mathrm{free}(M) \implies \lambda x.Mx \etaconv M$$
    \end{frameddefn}

    \begin{example}[Eta conversioni]
        Si consideri la seguente lambda espressione $$\lambda x.(\lambda y.y)x$$ si noti che $\mathrm{free}(\lambda y.y) = \varnothing \implies x \notin \mathrm{free}(\lambda y.y)$ e dunque è possibile applicare l'eta conversione, ottenendo quindi $$\lambda x .(\lambda y.y) x \etaconv \lambda y.y$$
    \end{example}

    \begin{framedobs}{Cattura nelle eta conversioni}
        Si noti che, all'interno della \cref{eta conv}, la condizione per cui $x$ non sia libera garantisce che la conversione produca espressioni equivalenti; infatti, se $x$ fosse libera in $M$, poiché non lo sarebbe comunque in $(\lambda x.Mx)$, l'eta conversione non avrebbe mantenuto l'equivalenza.
    \end{framedobs}

    \chapter{Paradigma imperativo}

    \section{Programmi}
    
    \subsection{Memoria}

    \begin{frameddefn}{Programma}
        Nel paradigma imperativo, un \tbf{programma} è un componente semantico che non restituisce valori --- dunque non ha \tit{side effect} --- ma cambiano il valore della memoria.
    \end{frameddefn}

    \begin{frameddefn}[label={store}]{Memoria}
        Sia $G$ una grammatica composta da programmi; per simulare la \tbf{memoria}, all'interno del paradigma imperativo verranno utilizzati ambienti definiti come segue: $$\mathrm{Env} := \{f \mid f : \mathrm{Var} \xrightarrow{fin} \mathrm{Loc} \}$$ dove $\mathrm{Loc}$ è un insieme di locazioni di memoria; inoltre, si definisce il seguente insieme $$\mathrm{Store} := \{f \mid f : \mathrm{Loc} \xrightarrow{fin} \mathrm{Val} \}$$ dunque, le funzioni $E \in \mathrm{Env}$ associano le variabili ad una locazione in memoria, mentre le funzioni $S \in \mathrm{Store}$ associano le locazioni ai valori, simulando quindi la struttura dei \tit{puntatori}, i quali caratterizzano i linguaggi imperativi.
    \end{frameddefn}

    \subsection{Clausole imperative}

    \begin{frameddefn}{Clausola $skip$}
        Sia $G$ una grammatica; allora, è possibile definire su $G$ la clausola $skip$, che equivale a non effettuare alcuna operazione.
    \end{frameddefn}
    
    \begin{frameddefn}{Clausola $seq$}
        Sia $G$ una grammatica composta da programmi, e sia $G_p$ l'insieme dei suoi programmi; allora, è possibile definire su $G$ una funzione $seq$, come segue: $$\func{seq}{G_p \times G_p}{G_p}$$ e verrà utilizzata attraverso la sintassi $$\ttt{<program>}_1;\ttt{<program>}_2$$ che sta ad indicare che verrà prima eseguito $\ttt{<program>}_1$, e successivamente $\ttt{<program>}_2$.
    \end{frameddefn}

    \begin{frameddefn}{Clausola $ite$}
        Sia $G$ una grammatica composta da programmi, e siano $G_p$ ed $G_M$ rispettivamente l'insieme dei suoi programmi e delle sue espressioni; allora, è possibile definire su $G$ una funzione $ite$ (\tit{if-then-else}), come segue: $$\func{ite}{G_M \times G_p \times G_p}{G_p}$$ e verrà utilizzata attraverso la sintassi $$\ite{\ttt{\_expression\_}}{\ttt{<program>}_1}{\ttt{<program>}_2}$$ dove se $M$ è un espressione che può essere valutata a $true$, verrà eseguito $\ttt{<program>}_1$, altrimenti verrà eseguito $\ttt{<program>}_2$.
    \end{frameddefn}

    \begin{frameddefn}{Clausola $while$}
        Sia $G$ una grammatica composta da programmi, e siano $G_p$ ed $G_M$ rispettivamente l'insieme dei suoi programmi e delle sue espressioni; allora, è possibile definire su $G$ una funzione $while$, come segue: $$\func{while}{G_M \times G_p}{G_p}$$ e verrà utilizzata attraverso la sintassi $$\while{\ttt{\_expression\_}}{\ttt{<program>}}$$ dove --- se \ttt{\_expression\_} è un espressione che può essere valutata a $true$ o $false$ --- viene eseguito $\ttt{<program>}$ fintanto che \ttt{\_expression\_} viene valutata a $true$.
    \end{frameddefn}

    \begin{frameddefn}{Clausola $var$}
        TODO
    \end{frameddefn}

    \begin{frameddefn}{Clausola $assign$}
        Sia $G$ una grammatica composta da programmi, e sia $G_M$ l'insieme delle sue espressioni; allora, è possibile deifnire su $G$ una funzione $assign$, come segue: $$\func{assign}{\mathrm{Var} \times G_M}{G}$$ e verrà utilizzata attraverso la sintassi $$\ttt{*variable*}  := \ttt{\_expression\_}$$ all'interno della quale, a \ttt{*variable*}, verrà assegnato il valore di \ttt{\_expression\_}.
    \end{frameddefn}

    \begin{example}[Grammatica $Imp$]
        \label{imp}
        Si consideri la grammatica $Exp$ definita all'interno dell'\cref{exp} (si noti che non si tratta di $Exp$ estesa); è possibile estenderla come segue: $$M,N ::= k \ | \ true \ | \ false \ | \ x \ | \ M \ \ttt + \ N \ | \ M \ \ttt * \ N \ | \ M \ \ttt < \ N$$ dove $true$ e $false$ sono valori booleani di verità. Allora, sia $Imp$ la grammatica composta da tale estensione di $Exp$, e dalla seguente: $$p,q ::= skip \ | \ p;q \ | \ \ite{M}{p}{q} \ | \ \while{M}{p} \ | \ \varin{x}{M}{p} \ | \ x:=M $$ L'insieme degli ambienti di $Imp$ è strutturato come nella \cref{store}. Inoltre, per effettuare le valutazioni, vengono definite le seguenti semantiche operazionali: $$\centeredsoe{\stackrel{M}{\leadsto}\ \subseteq \mathrm{Env} \times Exp \times \mathrm{Store} \times \mathrm{Val} \\ \stackrel{p}{\leadsto} \ \subseteq \mathrm{Env} \times Imp \times \mathrm{Store} \times \mathrm{Store}}$$ ed i loro giudizi operazionali verranno indicati come segue: $$\centeredsoe{\opjudstore[M]{E}{M}{S}{v} \\ \opjudstore[p]{E}{p}{S}{S}}$$
    \end{example}

    \begin{framedobs}{Semantiche di $Imp$}
        Sia $Imp$ la grammatica dell'\cref{imp}, e si considerino le sue semantiche operazionali; esse sono definite tali che la semantica $\stackrel{M}{\leadsto}$ delle espressioni sia in grado di restituire valori, ma non di cambiare la memoria, mentre la semantica $\stackrel{p}{\leadsto}$ dei programmi non restituisca valori, ma alteri lo stato della memoria. 
    \end{framedobs}

    \begin{example}[Semantica operazionale di $Imp$]
        \label{imp sem}
        Sia $Imp$ la grammatica definita all'interno dell'\cref{imp}, e siano $E \in \mathrm{Env}$ e $S \in \mathrm{Store}$; allora, si definiscono le seguenti regole operazionali (si noti che, per brevità, verrà utilizzato il simbolo $\leadsto$ all'interno dei giudizi di entrambe le semantiche di $Imp$):

        \begin{itemize}
            \item \tbf{costanti}: $$[const] \ \opjudstore{E}{k}{S}{S}$$
            \item \tbf{variabili}: $$\forall x \in \mathrm{Var} \quad \exists v \in \mathrm{Val} \mid S(E(x)) = v \implies [vars] \ \opjudstore{E}{x}{S}{v}$$
            \item \tbf{somme}: \centeredeq{0.9}{$\forall M,N \in Exp, v \in \mathrm{Val} \quad \exists v_1, v_2 \in \mathrm{Val} \mid v = v_1 + v_2 \implies [plus] \ \dfrac{\opjudstore{E}{M}{S}{v_1} \quad \opjudstore{E}{N}{S}{v_2}}{\opjudstore{E}{M \ \ttt + \ N}{S}{v}}$}
            \item \tbf{prodotti}: \centeredeq{0.9}{$\forall M,N \in Exp, v \in \mathrm{Val} \quad \exists v_1, v_2 \in \mathrm{Val} \mid v = v_1 \cdot v_2 \implies [times] \ \dfrac{\opjudstore{E}{M}{S}{v_1} \quad \opjudstore{E}{N}{S}{v_2}}{\opjudstore{E}{M \ \ttt * \ N}{S}{v}}$}
            \item \tbf{minorazioni}: $$\forall M, N \in Exp, v_1, v_2 \in \mathrm{Store} \quad v_1 < v_2 \implies [lt_1] \ \dfrac{\opjudstore{E}{M}{S}{v_1} \quad \opjudstore{E}{N}{S}{v_2}}{\opjudstore{E}{M \ \ttt < \ N}{S}{true}}$$ $$\forall M, N \in Exp, v_1, v_2 \in \mathrm{Store} \quad v_1 \ge v_2 \implies [lt_2] \ \dfrac{\opjudstore{E}{M}{S}{v_1} \quad \opjudstore{E}{N}{S}{v_2}}{\opjudstore{E}{M \ \ttt < \ N}{S}{false}}$$
            \item \tbf{skip}: $$[skip] \ \opjudstore{E}{skip}{S}{S}$$
            \item \tbf{esecuzioni sequenziali}: $$\forall p, q \in Imp, S', S'' \in \mathrm{Store} \quad [seq] \ \dfrac{\opjudstore{E}{p}{ S}{S'} \quad \opjudstore{E}{q}{ S'}{S''}}{\opjudstore{E}{p;q}{S}{S''}}$$
            \item \tbf{if-then-else}: $$\forall p, q \in Imp, S' \in \mathrm{Store} \quad [ite_1] \ \dfrac{\opjudstore{E}{M}{ S}{true} \quad \opjudstore{E}{p}{S}{S'}}{\opjudstore{E}{\ite{M}{p}{q}}{S}{S'}}$$ $$\forall p, q \in Imp, S'' \in \mathrm{Store} \quad [ite_2] \ \dfrac{\opjudstore{E}{M}{S}{false} \quad \opjudstore{E}{p}{S}{S''}}{\opjudstore{E}{\ite{M}{p}{q}}{S}{S''}}$$
            \item \tbf{while}: \centeredeq{0.9}{$\forall M \in Exp, S', S'' \in \mathrm{Store} \quad [while_1] \ \dfrac{\opjudstore{E}{M}{S}{true} \quad \opjudstore{E}{p}{S}{S'} \quad \opjudstore{E}{\while{M}{p}}{ S'}{S''}}{\opjudstore{E}{\while{M}{p}}{ S}{S''}}$} $$\forall M \in Exp \quad [while_2] \ \dfrac{\opjudstore{E}{M}{S}{false}}{\opjudstore{E}{\while{M}{p}}{S}{S}}$$
            \item \tbf{dichiarazioni ed assegnazioni}: $$\forall x \in \mathrm{Var}, M \in Exp, p \in Imp, S' \in \mathrm{Store}, v \in \mathrm{Val} \quad \exists l \in \mathrm{Loc} \mid l \notin \dom(S) \implies$$ $$\implies [var] \ \dfrac{\opjudstore{E}{M}{S}{v} \quad \opjudstore{E\{(x,l)\}}{p}{S\{(l,v)\}}{S'}}{\opjudstore{E}{\varin{x}{M}{p}}{S}{S'}}$$
            \item \tbf{assegnazioni}: \centeredeq{0.9}{$\forall x \in \mathrm{Var}, M \in Exp \quad \exists l \in \mathrm{Loc} \mid E(x) = l \implies [assign] \ \dfrac{\opjudstore{E}{M}{S}{v}}{\opjudstore{E}{x := M}{ S}{S\{(l, v)\}}}$}
        \end{itemize}
    \end{example}

    \subsection{Memoria contigua}

    \begin{frameddefn}{Memoria contigua}
        Sia $G$ una grammatica composta da programmi, e siano $G_p$ e $G_M$ rispettivamente l'insieme dei suoi programmi e delle sue espressioni; al fine di implementare gli \tit{array} all'interno del paradigma imperativo, è necessario definire la \tbf{memoria contigua}, dunque si definisce il seguente insieme di locazioni $$\displaystyle \mathrm{Loc}^+ := \bigcup_{n \in \N}{\mathrm{Loc}^n}$$ poiché è in grado di supportare infinite sequenze di elementi, e si assume che queste siano contigue in memoria.
    \end{frameddefn}

    \subsection{Clausole imperative a memoria contigua}

    \begin{frameddefn}{Clausola $loc$}
        TODO
    \end{frameddefn}

    \begin{frameddefn}{Clausola $arr$}
        TODO
    \end{frameddefn}

    \begin{frameddefn}{Clausola $proc$}
        Sia $G$ una grammatica composta da programmi, e sia $G_p$ l'insieme dei suoi programmi; allora, è possibile definire su $G$ una funzione $proc$, come segue: $$\func{proc}{\mathrm{Var} \times \mathrm{Var} \times G_p \times G_p}{G_p}$$ e verrà utilizzata attraverso la sintassi $$\proc{\ttt{*variable*}_1}{\ttt{*variable*}_2}{\ttt{<program>}_1}{\ttt{<program>}_2}$$ la quale definisce la \tit{procedura} $\ttt{*variable*}_1(\ttt{*variable*}_2)$, il cui corpo è costituito da $\ttt{<program>}_1$, ed è possibile utilizzarla all'interno di $\ttt{<program>}_2$.
    \end{frameddefn}

    \begin{frameddefn}{Clausola $call$}
        Sia $G$ una grammatica composta da programmi, e siano $G_p$ e $G_M$ rispettivamente l'insieme dei suoi programmi e delle sue espressioni; allora, è possibile definire su $G$ una funzione $call$, come segue: $$\func{call}{\mathrm{Var} \times G_M}{G_p}$$ e verrà utilizzata attraverso la sintassi $$\call{\ttt{*variable*}}{\ttt{\_expression\_}}$$ la quale effettua una chiamata alla procedura $\ttt{*variable*}$, fornendole come parametro $\ttt{\_expression\_}$.
    \end{frameddefn}

    \begin{example}[Grammatica $All$]
        \label{all}
        Sia $All$ la grammatica, estensione di $Imp$ definita nell'\cref{imp}, composta dalle seguenti grammatiche:

        $$\leftsoe{k ::= \ttt 0 \ | \ \ttt 1 \ | \ \ldots \ | \ true \ | \ false \\ V ::= x \ | \ x[M] \\ M, N ::= k \ | \ V \ | \ M \ \ttt + \ N \ | \ | \ M \ \ttt * \ N \ | \ M \ \ttt < \ N \\ p,q ::= skip \ | \ p;q \ | \ \ite{M}{p}{q} \ | \\ \quad \quad \quad \ | \ \while{M}{p} \ | \ \varin{x}{M}{p} \ | \ \arrin{x}{[M_0, \ldots, M_n]}{p} \ | \\ \quad \quad \quad \ | \ V := M \ | \ \procin{y}{x}{p}{x} \ | \ \call{y}{M}}$$

        Dunque, essa è composta da:

        \begin{enumerate}[label=\roman*), font=\itshape]
            \item una grammatica per le \tit{costanti};
            \item una grammatica per le \tit{espressioni assegnabili}, che prende il nome di $LExp$ (\tit{left expressions}); per valutare le sue espressioni, si introduce la seguente semantica: $$\stackrel{V}{\leadsto} \ \subseteq \mathrm{Env} \times LExp \times \mathrm{Store} \times \mathrm{Loc}$$
            \item una grammatica per le \tit{espressioni valutabili}, la quale consiste in un'estensione di $Exp$ definita nell'\cref{exp};
            \item una grammatica per i \tit{programmi}, la quale consiste in un'estensione di $Imp$ definita nell'\cref{imp}.
        \end{enumerate}

        Si noti che, poiché tale grammatica supporta gli array, è necessario fornire ad $All$ locazioni di memoria contigue. Inoltre, l'insieme degli ambienti di $All$ è definito come segue: $$\mathrm{Env} := \{f \mid f : \mathrm{Var} \xrightarrow{fin} \mathrm{Loc}^+ \cup (\mathrm{Var} \times All \times \mathrm{Env})\}$$
    \end{example}

    \begin{example}
        \label{all sem}
        Sia $All$ la grammatica definita all'interno dell'\cref{all}, e siano $E \in \mathrm{Env}$ e $S \in \mathrm{Store}$; allora, in aggiunta alle regole $$[const], \ [plus], \ [times], \ [lt_1], \ [lt_2], \ [skip], \ [seq], \ [ite_1], \ [ite_2], \ [while_1], \ [while_2]$$ descritte nell'\cref{imp sem}, si definiscono le seguenti:

        \begin{itemize}
            \item \tbf{locazioni}: $$\forall x \in \mathrm{Var} \quad \exists l \in \mathrm{Loc}^+ \mid E(x) = l \implies [loc_1] \ \opjudstore[V]{E}{x}{S}{l}$$
            \item \tbf{locazioni in array}: $$\forall n \in \N, x \in \mathrm{Var} \quad \exists (l_0, \ldots, l_n) \in \mathrm{Loc}^+ \mid E(x) = \abk{l_0, \ldots, l_n} \implies$$ $$\implies \forall m \in [0, n] \quad [loc_2] \ \dfrac{\opjudstore[M]{E}{M}{S}{m}}{\opjudstore[V]{E}{x[M]}{S}{l_m}}$$
            \item \tbf{reference}: $$\forall V \in LExp, l \in \mathrm{Loc} \quad \exists v \in \mathrm{Val} \mid S(l) = v \implies [ref] \ \dfrac{\opjudstore[V]{E}{V}{S}{l}}{\opjudstore[M]{E}{V}{S}{v}}$$
            \item \tbf{assegnazioni}: \centeredeq{0.9}{$\forall V \in LExp, M \in Exp, l \in \mathrm{Loc}, v \in \mathrm{Val} \quad [assign] \ \dfrac{\opjudstore[M]{E}{M}{S}{v} \quad \opjudstore[V]{E}{V}{S}{l}}{\opjudstore[p]{E}{V := M}{S}{S\{(l,v)\}}}$}
            \item \tbf{array}: $$\forall n \in \N, S' \in \mathrm{Store}, x \in \mathrm{Var}, M_0, \ldots, M_n \in Exp, p \in Imp, v_0, \ldots, v_n \in \mathrm{Val}$$ $$\exists (l_0, \ldots, l_n) \in \mathrm{Loc}^+ \mid l_0, \ldots, l_n \notin \dom(S) \implies$$ \centeredeq{0.9}{$\implies [arr] \ \dfrac{\opjudstore[M]{E}{M_0}{S}{v_0} \quad \ldots \quad \opjudstore[M]{E}{M_n}{S}{v_n} \quad \opjudstore[p]{E\{(x, (l_0, \ldots, l_n))\}}{p}{S\{(l_0, v_0), \ldots, (l_n, v_n)\}}{S'}}{\opjudstore[p]{E}{\arrin{x}{[M_0, \ldots, M_n]}{p}}{S}{S'}}$}
            \item \tbf{procedure}: $$\forall y,x \in \mathrm{Var}, p, q \in Imp, S' \in \mathrm{Store} \quad [proc] \ \dfrac{\opjudstore[p]{E\{(y,(x,p, E))\}}{q}{S}{S'}}{\opjudstore[p]{E}{\procin{y}{x}{p}{q}}{S}{S'}}$$
        \end{itemize}

        Per quanto concerne le regole della clausola $call$, si consultino l'\cref{all v}, l'\cref{all r} e l'\cref{all n}.
    \end{example}

    \begin{framedobs}{Variabili in $All$}
        Si considerino le regole della grammatica $All$, definite all'interno dell'\cref{all sem}, e si noti che in essa non è presente la regola di inferenza $[vars]$; infatti, all'interno di $All$, l'unico modo per accedere al valore di una variabile è tramite \tit{reference}, dunque utilizzando $[loc_1]$ assieme a $[ref]$. Questo è necessario poiché $All$ supporta gli array, e dunque TODO.
    \end{framedobs}

    \subsection{Semantiche delle chiamate}

    \begin{frameddefn}{Semantiche di $call$}
        TODO
    \end{frameddefn}

    \begin{framedobs}[label={all v}]{$All_\mathrm{V}$}
        Sia $All$ la grammatica definita nell'\cref{all}; per poter valutare le sue espressioni attraverso la semantica \tit{call-by-value}, è necessario definire la seguente regola di inferenza: \centeredeq{0.9}{$\forall y \in \mathrm{Var}, M \in Exp, v \in \mathrm{Val}, p \in Imp \quad \exists l \in \mathrm{Loc} - \dom(S) \land E(y) = (x, p, E') \implies$} $$\implies \dfrac{\opjudstore[M]{E}{M}{S}{v} \quad \opjudstore[p]{E'\{(x,l)\}}{p}{S\{(l,v)\}}{S'}}{\opjudstore[p]{E}{\call{y}{M}}{S}{S'}}$$ per certi $E, E' \in \mathrm{Env}, S,S' \in \mathrm{Store}$, poiché:

        \begin{itemize}
            \item l'espressione $M$ viene valutata attraverso la semantica $\stackrel{M}{\leadsto}$, la quale restituisce un valore $v$;
            \item viene effettuato il calcolo di $p$, con l'ambiente salvato precedentemente concatenato $(x,l)$, e con lo store corrente concatenato a $(l,v)$, per una qualche nuova locazione di memoria $l$.
        \end{itemize}
    \end{framedobs}

    \begin{framedobs}[label={all r}]{$All_\mathrm{R}$}
        Sia $All$ la grammatica definita nell'\cref{all}; per poter valutare le sue espressioni attraverso la semantica \tit{call-by-reference}, è necessario definire la seguente regola di inferenza: \centeredeq{0.9}{$\forall y \in \mathrm{Var}, M \in Exp, v \in \mathrm{Val}, p \in Imp \quad \exists l \in \mathrm{Loc} - \dom(S) \land E(y) = (x, p, E') \implies$} $$\implies \dfrac{\opjudstore[V]{E}{V}{S}{l} \quad \opjudstore[p]{E'\{(x,l)\}}{p}{S}{S'}}{\opjudstore[p]{E}{\call{y}{V}}{S}{S'}}$$ per certi $E,E' \in \mathrm{Env}, S,S' \in \mathrm{Store}$, poiché

        \begin{itemize}
            \item l'espressione $M$ viene valutata attraverso la semantica $\stackrel{V}{\leadsto}$, la quale restituisce una locazione $l$;
            \item TODO
        \end{itemize}
    \end{framedobs}

    \begin{framedobs}[label={all n}]{$All_\mathrm{N}$}
        TODO
    \end{framedobs}

\end{document}
